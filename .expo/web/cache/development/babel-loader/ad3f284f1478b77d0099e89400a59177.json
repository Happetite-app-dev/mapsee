{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar InteractionManager = function () {\n  function InteractionManager() {\n    _classCallCheck(this, InteractionManager);\n\n    _defineProperty(this, \"waitForRelations\", new Map());\n\n    _defineProperty(this, \"simultaneousRelations\", new Map());\n  }\n\n  _createClass(InteractionManager, [{\n    key: \"configureInteractions\",\n    value: function configureInteractions(handler, config) {\n      this.dropRelationsForHandlerWithTag(handler.getTag());\n\n      if (config.waitFor) {\n        var waitFor = [];\n        config.waitFor.forEach(function (handler) {\n          if (typeof handler === 'number') {\n            waitFor.push(handler);\n          } else {\n            waitFor.push(handler.handlerTag);\n          }\n        });\n        this.waitForRelations.set(handler.getTag(), waitFor);\n      }\n\n      if (config.simultaneousHandlers) {\n        var simultaneousHandlers = [];\n        config.simultaneousHandlers.forEach(function (handler) {\n          if (typeof handler === 'number') {\n            simultaneousHandlers.push(handler);\n          } else {\n            simultaneousHandlers.push(handler.handlerTag);\n          }\n        });\n        this.simultaneousRelations.set(handler.getTag(), simultaneousHandlers);\n      }\n\n      handler.setInteractionManager(this);\n    }\n  }, {\n    key: \"shouldWaitForHandlerFailure\",\n    value: function shouldWaitForHandlerFailure(handler, otherHandler) {\n      var waitFor = this.waitForRelations.get(handler.getTag());\n\n      if (!waitFor) {\n        return false;\n      }\n\n      var shouldWait = false;\n      waitFor.forEach(function (tag) {\n        if (tag === otherHandler.getTag()) {\n          shouldWait = true;\n          return;\n        }\n      });\n      return shouldWait;\n    }\n  }, {\n    key: \"shouldRecognizeSimultaneously\",\n    value: function shouldRecognizeSimultaneously(handler, otherHandler) {\n      var simultaneousHandlers = this.simultaneousRelations.get(handler.getTag());\n\n      if (!simultaneousHandlers) {\n        return false;\n      }\n\n      var shouldRecognizeSimultaneously = false;\n      simultaneousHandlers.forEach(function (tag) {\n        if (tag === otherHandler.getTag()) {\n          shouldRecognizeSimultaneously = true;\n          return;\n        }\n      });\n      return shouldRecognizeSimultaneously;\n    }\n  }, {\n    key: \"shouldRequireHandlerToWaitForFailure\",\n    value: function shouldRequireHandlerToWaitForFailure(_handler, _otherHandler) {\n      return false;\n    }\n  }, {\n    key: \"shouldHandlerBeCancelledBy\",\n    value: function shouldHandlerBeCancelledBy(_handler, _otherHandler) {\n      return false;\n    }\n  }, {\n    key: \"dropRelationsForHandlerWithTag\",\n    value: function dropRelationsForHandlerWithTag(handlerTag) {\n      this.waitForRelations.delete(handlerTag);\n      this.simultaneousRelations.delete(handlerTag);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.waitForRelations.clear();\n      this.simultaneousRelations.clear();\n    }\n  }]);\n\n  return InteractionManager;\n}();\n\nexport { InteractionManager as default };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;IAGqBA,kB;EAAmB;IAAA;;IAAAC,0CACqB,IAAIC,GAAJ,EADrB;;IAAAD,+CAE0B,IAAIC,GAAJ,EAF1B;EAAA;;;;WAI/BC,+BAAsBC,OAAtBD,EAA+CE,MAA/CF,EAA+D;MACpE,KAAKG,8BAAL,CAAoCF,OAAO,CAACG,MAARH,EAApC;;MAEA,IAAIC,MAAM,CAACG,OAAX,EAAoB;QAClB,IAAMA,OAAiB,GAAG,EAA1B;QACAH,MAAM,CAACG,OAAPH,CAAeI,OAAfJ,CAAwBD,iBAAD,EAA4B;UACjD,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;YAC/BI,OAAO,CAACE,IAARF,CAAaJ,OAAbI;UADF,OAEO;YACLA,OAAO,CAACE,IAARF,CAAaJ,OAAO,CAACO,UAArBH;UACD;QALH;QAQA,KAAKI,gBAAL,CAAsBC,GAAtB,CAA0BT,OAAO,CAACG,MAARH,EAA1B,EAA4CI,OAA5C;MACD;;MAED,IAAIH,MAAM,CAACS,oBAAX,EAAiC;QAC/B,IAAMA,oBAA8B,GAAG,EAAvC;QACAT,MAAM,CAACS,oBAAPT,CAA4BI,OAA5BJ,CAAqCD,iBAAD,EAA4B;UAC9D,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;YAC/BU,oBAAoB,CAACJ,IAArBI,CAA0BV,OAA1BU;UADF,OAEO;YACLA,oBAAoB,CAACJ,IAArBI,CAA0BV,OAAO,CAACO,UAAlCG;UACD;QALH;QAQA,KAAKC,qBAAL,CAA2BF,GAA3B,CAA+BT,OAAO,CAACG,MAARH,EAA/B,EAAiDU,oBAAjD;MACD;;MACDV,OAAO,CAACY,qBAARZ,CAA8B,IAA9BA;IACD;;;WAEMa,qCACLb,OADKa,EAELC,YAFKD,EAGI;MACT,IAAMT,OAA6B,GAAG,KAAKI,gBAAL,CAAsBO,GAAtB,CACpCf,OAAO,CAACG,MAARH,EADoC,CAAtC;;MAGA,IAAI,CAACI,OAAL,EAAc;QACZ,OAAO,KAAP;MACD;;MAED,IAAIY,UAAU,GAAG,KAAjB;MAEAZ,OAAO,CAACC,OAARD,CAAiBa,aAAD,EAAuB;QACrC,IAAIA,GAAG,KAAKH,YAAY,CAACX,MAAbW,EAAZ,EAAmC;UACjCE,UAAU,GAAG,IAAbA;UACA;QACD;MAJH;MAOA,OAAOA,UAAP;IACD;;;WAEME,uCACLlB,OADKkB,EAELJ,YAFKI,EAGI;MACT,IAAMR,oBAEO,GAAG,KAAKC,qBAAL,CAA2BI,GAA3B,CAA+Bf,OAAO,CAACG,MAARH,EAA/B,CAFhB;;MAGA,IAAI,CAACU,oBAAL,EAA2B;QACzB,OAAO,KAAP;MACD;;MAED,IAAIQ,6BAA6B,GAAG,KAApC;MAEAR,oBAAoB,CAACL,OAArBK,CAA8BO,aAAD,EAAuB;QAClD,IAAIA,GAAG,KAAKH,YAAY,CAACX,MAAbW,EAAZ,EAAmC;UACjCI,6BAA6B,GAAG,IAAhCA;UACA;QACD;MAJH;MAOA,OAAOA,6BAAP;IACD;;;WAEMC,8CACLC,QADKD,EAELE,aAFKF,EAGI;MACT,OAAO,KAAP;IACD;;;WAEMG,oCACLF,QADKE,EAELD,aAFKC,EAGI;MACT,OAAO,KAAP;IACD;;;WAEMpB,wCAA+BK,UAA/BL,EAAyD;MAC9D,KAAKM,gBAAL,CAAsBe,MAAtB,CAA6BhB,UAA7B;MACA,KAAKI,qBAAL,CAA2BY,MAA3B,CAAkChB,UAAlC;IACD;;;WAEMiB,iBAAQ;MACb,KAAKhB,gBAAL,CAAsBiB,KAAtB;MACA,KAAKd,qBAAL,CAA2Bc,KAA3B;IACD;;;;;;SAvGkB7B,kB","names":["InteractionManager","_defineProperty","Map","configureInteractions","handler","config","dropRelationsForHandlerWithTag","getTag","waitFor","forEach","push","handlerTag","waitForRelations","set","simultaneousHandlers","simultaneousRelations","setInteractionManager","shouldWaitForHandlerFailure","otherHandler","get","shouldWait","tag","shouldRecognizeSimultaneously","shouldRequireHandlerToWaitForFailure","_handler","_otherHandler","shouldHandlerBeCancelledBy","delete","reset","clear"],"sources":["InteractionManager.ts"],"sourcesContent":["import GestureHandler from '../handlers/GestureHandler';\nimport { Config, Handler } from '../interfaces';\n\nexport default class InteractionManager {\n  private readonly waitForRelations: Map<number, number[]> = new Map();\n  private readonly simultaneousRelations: Map<number, number[]> = new Map();\n\n  public configureInteractions(handler: GestureHandler, config: Config) {\n    this.dropRelationsForHandlerWithTag(handler.getTag());\n\n    if (config.waitFor) {\n      const waitFor: number[] = [];\n      config.waitFor.forEach((handler: Handler): void => {\n        if (typeof handler === 'number') {\n          waitFor.push(handler);\n        } else {\n          waitFor.push(handler.handlerTag);\n        }\n      });\n\n      this.waitForRelations.set(handler.getTag(), waitFor);\n    }\n\n    if (config.simultaneousHandlers) {\n      const simultaneousHandlers: number[] = [];\n      config.simultaneousHandlers.forEach((handler: Handler): void => {\n        if (typeof handler === 'number') {\n          simultaneousHandlers.push(handler);\n        } else {\n          simultaneousHandlers.push(handler.handlerTag);\n        }\n      });\n\n      this.simultaneousRelations.set(handler.getTag(), simultaneousHandlers);\n    }\n    handler.setInteractionManager(this);\n  }\n\n  public shouldWaitForHandlerFailure(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const waitFor: number[] | undefined = this.waitForRelations.get(\n      handler.getTag()\n    );\n    if (!waitFor) {\n      return false;\n    }\n\n    let shouldWait = false;\n\n    waitFor.forEach((tag: number): void => {\n      if (tag === otherHandler.getTag()) {\n        shouldWait = true;\n        return; //Returns from callback\n      }\n    });\n\n    return shouldWait;\n  }\n\n  public shouldRecognizeSimultaneously(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const simultaneousHandlers:\n      | number[]\n      | undefined = this.simultaneousRelations.get(handler.getTag());\n    if (!simultaneousHandlers) {\n      return false;\n    }\n\n    let shouldRecognizeSimultaneously = false;\n\n    simultaneousHandlers.forEach((tag: number): void => {\n      if (tag === otherHandler.getTag()) {\n        shouldRecognizeSimultaneously = true;\n        return;\n      }\n    });\n\n    return shouldRecognizeSimultaneously;\n  }\n\n  public shouldRequireHandlerToWaitForFailure(\n    _handler: GestureHandler,\n    _otherHandler: GestureHandler\n  ): boolean {\n    return false;\n  }\n\n  public shouldHandlerBeCancelledBy(\n    _handler: GestureHandler,\n    _otherHandler: GestureHandler\n  ): boolean {\n    return false;\n  }\n\n  public dropRelationsForHandlerWithTag(handlerTag: number): void {\n    this.waitForRelations.delete(handlerTag);\n    this.simultaneousRelations.delete(handlerTag);\n  }\n\n  public reset() {\n    this.waitForRelations.clear();\n    this.simultaneousRelations.clear();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}