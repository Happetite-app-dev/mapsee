{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { State } from \"../../State\";\nimport PointerTracker from \"./PointerTracker\";\n\nvar GestureHandlerOrchestrator = function () {\n  function GestureHandlerOrchestrator() {\n    _classCallCheck(this, GestureHandlerOrchestrator);\n\n    _defineProperty(this, \"gestureHandlers\", []);\n\n    _defineProperty(this, \"awaitingHandlers\", []);\n\n    _defineProperty(this, \"handlersToCancel\", []);\n\n    _defineProperty(this, \"handlingChangeSemaphore\", 0);\n\n    _defineProperty(this, \"activationIndex\", 0);\n  }\n\n  _createClass(GestureHandlerOrchestrator, [{\n    key: \"scheduleFinishedHandlersCleanup\",\n    value: function scheduleFinishedHandlersCleanup() {\n      if (this.handlingChangeSemaphore === 0) {\n        this.cleanupFinishedHandlers();\n      }\n    }\n  }, {\n    key: \"cleanHandler\",\n    value: function cleanHandler(handler) {\n      handler.reset();\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_VALUE);\n    }\n  }, {\n    key: \"cleanupFinishedHandlers\",\n    value: function cleanupFinishedHandlers() {\n      for (var i = this.gestureHandlers.length - 1; i >= 0; --i) {\n        var handler = this.gestureHandlers[i];\n\n        if (!handler) {\n          continue;\n        }\n\n        if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n          this.gestureHandlers.splice(i, 1);\n          this.cleanHandler(handler);\n        }\n      }\n    }\n  }, {\n    key: \"hasOtherHandlerToWaitFor\",\n    value: function hasOtherHandlerToWaitFor(handler) {\n      var _this = this;\n\n      var hasToWait = false;\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (otherHandler && !_this.isFinished(otherHandler.getState()) && _this.shouldHandlerWaitForOther(handler, otherHandler)) {\n          hasToWait = true;\n          return;\n        }\n      });\n      return hasToWait;\n    }\n  }, {\n    key: \"tryActivate\",\n    value: function tryActivate(handler, event) {\n      if (this.hasOtherHandlerToWaitFor(handler)) {\n        this.addAwaitingHandler(handler);\n      } else {\n        this.makeActive(handler, event);\n      }\n    }\n  }, {\n    key: \"cleanupAwaitingHandlers\",\n    value: function cleanupAwaitingHandlers(handler) {\n      for (var i = 0; i < this.awaitingHandlers.length; ++i) {\n        if (!this.awaitingHandlers[i].isAwaiting() && this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)) {\n          this.cleanHandler(this.awaitingHandlers[i]);\n          this.awaitingHandlers.splice(i, 1);\n        }\n      }\n    }\n  }, {\n    key: \"onHandlerStateChange\",\n    value: function onHandlerStateChange(handler, newState, oldState, event) {\n      var _this2 = this;\n\n      this.handlingChangeSemaphore += 1;\n\n      if (this.isFinished(newState)) {\n        this.awaitingHandlers.forEach(function (otherHandler) {\n          if (_this2.shouldHandlerWaitForOther(otherHandler, handler)) {\n            if (newState === State.END) {\n              otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel(event);\n              otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(false);\n            } else {\n              _this2.tryActivate(otherHandler, event);\n            }\n          }\n        });\n      }\n\n      if (newState === State.ACTIVE) {\n        this.tryActivate(handler, event);\n      } else if (oldState === State.ACTIVE || oldState === State.END) {\n        if (handler.isActive()) {\n          handler.sendEvent(event, newState, oldState);\n        } else if (oldState === State.ACTIVE) {\n          handler.sendEvent(event, newState, State.BEGAN);\n        }\n      } else if (oldState !== State.UNDETERMINED || newState !== State.CANCELLED) {\n        handler.sendEvent(event, newState, oldState);\n      }\n\n      this.handlingChangeSemaphore -= 1;\n      this.scheduleFinishedHandlersCleanup();\n\n      if (this.awaitingHandlers.indexOf(handler) < 0) {\n        this.cleanupAwaitingHandlers(handler);\n      }\n    }\n  }, {\n    key: \"makeActive\",\n    value: function makeActive(handler, event) {\n      var _this3 = this;\n\n      var currentState = handler.getState();\n      handler.setActive(true);\n      handler.setShouldResetProgress(true);\n      handler.setActivationIndex(this.activationIndex++);\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (_this3.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n          _this3.handlersToCancel.push(otherHandler);\n        }\n      });\n\n      for (var i = this.handlersToCancel.length - 1; i >= 0; --i) {\n        var _this$handlersToCance;\n\n        (_this$handlersToCance = this.handlersToCancel[i]) === null || _this$handlersToCance === void 0 ? void 0 : _this$handlersToCance.cancel(event);\n      }\n\n      this.awaitingHandlers.forEach(function (otherHandler) {\n        if (_this3.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n          otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.cancel(event);\n          otherHandler === null || otherHandler === void 0 ? void 0 : otherHandler.setAwaiting(true);\n        }\n      });\n      handler.sendEvent(event, State.ACTIVE, State.BEGAN);\n\n      if (currentState !== State.ACTIVE) {\n        handler.sendEvent(event, State.END, State.ACTIVE);\n\n        if (currentState !== State.END) {\n          handler.sendEvent(event, State.UNDETERMINED, State.END);\n        }\n      }\n\n      if (handler.isAwaiting()) {\n        handler.setAwaiting(false);\n        handler.end(event);\n      }\n\n      this.handlersToCancel = [];\n    }\n  }, {\n    key: \"addAwaitingHandler\",\n    value: function addAwaitingHandler(handler) {\n      var alreadyExists = false;\n      this.awaitingHandlers.forEach(function (otherHandler) {\n        if (otherHandler === handler) {\n          alreadyExists = true;\n          return;\n        }\n      });\n\n      if (alreadyExists) {\n        return;\n      }\n\n      this.awaitingHandlers.push(handler);\n      handler.setAwaiting(true);\n      handler.setActivationIndex(this.activationIndex++);\n    }\n  }, {\n    key: \"recordHandlerIfNotPresent\",\n    value: function recordHandlerIfNotPresent(handler) {\n      var alreadyExists = false;\n      this.gestureHandlers.forEach(function (otherHandler) {\n        if (otherHandler === handler) {\n          alreadyExists = true;\n          return;\n        }\n      });\n\n      if (alreadyExists) {\n        return;\n      }\n\n      this.gestureHandlers.push(handler);\n      handler.setActive(false);\n      handler.setAwaiting(false);\n      handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n    }\n  }, {\n    key: \"shouldHandlerWaitForOther\",\n    value: function shouldHandlerWaitForOther(handler, otherHandler) {\n      return handler !== otherHandler && (handler.shouldWaitForHandlerFailure(otherHandler) || otherHandler.shouldRequireToWaitForFailure(handler));\n    }\n  }, {\n    key: \"canRunSimultaneously\",\n    value: function canRunSimultaneously(gh1, gh2) {\n      return gh1 === gh2 || gh1.shouldRecognizeSimultaneously(gh2) || gh2.shouldRecognizeSimultaneously(gh1);\n    }\n  }, {\n    key: \"shouldHandlerBeCancelledBy\",\n    value: function shouldHandlerBeCancelledBy(handler, otherHandler) {\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n\n      if (!PointerTracker.shareCommonPointers(handlerPointers, otherPointers) && handler.getView() !== otherHandler.getView()) {\n        return this.checkOverlap(handler, otherHandler);\n      }\n\n      if (this.canRunSimultaneously(handler, otherHandler)) {\n        return false;\n      }\n\n      if (handler !== otherHandler && (handler.isAwaiting() || handler.getState() === State.ACTIVE)) {\n        return handler.shouldBeCancelledByOther(otherHandler);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"checkOverlap\",\n    value: function checkOverlap(handler, otherHandler) {\n      var handlerPointers = handler.getTrackedPointersID();\n      var otherPointers = otherHandler.getTrackedPointersID();\n      var overlap = false;\n      handlerPointers.forEach(function (pointer) {\n        var handlerX = handler.getTracker().getLastX(pointer);\n        var handlerY = handler.getTracker().getLastY(pointer);\n\n        if (handler.getEventManager().isPointerInBounds({\n          x: handlerX,\n          y: handlerY\n        }) && otherHandler.getEventManager().isPointerInBounds({\n          x: handlerX,\n          y: handlerY\n        })) {\n          overlap = true;\n        }\n      });\n      otherPointers.forEach(function (pointer) {\n        var otherX = otherHandler.getTracker().getLastX(pointer);\n        var otherY = otherHandler.getTracker().getLastY(pointer);\n\n        if (handler.getEventManager().isPointerInBounds({\n          x: otherX,\n          y: otherY\n        }) && otherHandler.getEventManager().isPointerInBounds({\n          x: otherX,\n          y: otherY\n        })) {\n          overlap = true;\n        }\n      });\n      return overlap;\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished(state) {\n      return state === State.END || state === State.FAILED || state === State.CANCELLED;\n    }\n  }], [{\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!GestureHandlerOrchestrator.instance) GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n      return GestureHandlerOrchestrator.instance;\n    }\n  }]);\n\n  return GestureHandlerOrchestrator;\n}();\n\nexport { GestureHandlerOrchestrator as default };\n\n_defineProperty(GestureHandlerOrchestrator, \"instance\", void 0);","map":{"version":3,"mappings":"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","names":["State","PointerTracker","GestureHandlerOrchestrator","constructor","_defineProperty","scheduleFinishedHandlersCleanup","handlingChangeSemaphore","cleanupFinishedHandlers","cleanHandler","handler","reset","setActive","setAwaiting","setActivationIndex","Number","MAX_VALUE","i","gestureHandlers","length","isFinished","getState","isAwaiting","splice","hasOtherHandlerToWaitFor","hasToWait","forEach","otherHandler","shouldHandlerWaitForOther","tryActivate","event","addAwaitingHandler","makeActive","cleanupAwaitingHandlers","awaitingHandlers","onHandlerStateChange","newState","oldState","END","cancel","ACTIVE","isActive","sendEvent","BEGAN","UNDETERMINED","CANCELLED","indexOf","currentState","setShouldResetProgress","activationIndex","shouldHandlerBeCancelledBy","handlersToCancel","push","end","alreadyExists","recordHandlerIfNotPresent","MAX_SAFE_INTEGER","shouldWaitForHandlerFailure","shouldRequireToWaitForFailure","canRunSimultaneously","gh1","gh2","shouldRecognizeSimultaneously","handlerPointers","getTrackedPointersID","otherPointers","shareCommonPointers","getView","checkOverlap","shouldBeCancelledByOther","overlap","pointer","handlerX","getTracker","getLastX","handlerY","getLastY","getEventManager","isPointerInBounds","x","y","otherX","otherY","state","FAILED","instance"],"sources":["GestureHandlerOrchestrator.ts"],"sourcesContent":["import { State } from '../../State';\nimport { AdaptedPointerEvent } from '../interfaces';\n\nimport GestureHandler from '../handlers/GestureHandler';\nimport PointerTracker from './PointerTracker';\n\nexport default class GestureHandlerOrchestrator {\n  private static instance: GestureHandlerOrchestrator;\n\n  private gestureHandlers: GestureHandler[] = [];\n  private awaitingHandlers: GestureHandler[] = [];\n  private handlersToCancel: GestureHandler[] = [];\n\n  private handlingChangeSemaphore = 0;\n  private activationIndex = 0;\n\n  // Private beacuse of Singleton\n  // eslint-disable-next-line no-useless-constructor, @typescript-eslint/no-empty-function\n  private constructor() {}\n\n  private scheduleFinishedHandlersCleanup(): void {\n    if (this.handlingChangeSemaphore === 0) {\n      this.cleanupFinishedHandlers();\n    }\n  }\n\n  private cleanHandler(handler: GestureHandler): void {\n    handler.reset();\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_VALUE);\n  }\n\n  private cleanupFinishedHandlers(): void {\n    for (let i = this.gestureHandlers.length - 1; i >= 0; --i) {\n      const handler = this.gestureHandlers[i];\n      if (!handler) {\n        continue;\n      }\n\n      if (this.isFinished(handler.getState()) && !handler.isAwaiting()) {\n        this.gestureHandlers.splice(i, 1);\n\n        this.cleanHandler(handler);\n      }\n    }\n  }\n\n  private hasOtherHandlerToWaitFor(handler: GestureHandler): boolean {\n    let hasToWait = false;\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (\n        otherHandler &&\n        !this.isFinished(otherHandler.getState()) &&\n        this.shouldHandlerWaitForOther(handler, otherHandler)\n      ) {\n        hasToWait = true;\n        return;\n      }\n    });\n\n    return hasToWait;\n  }\n\n  private tryActivate(\n    handler: GestureHandler,\n    event: AdaptedPointerEvent\n  ): void {\n    if (this.hasOtherHandlerToWaitFor(handler)) {\n      this.addAwaitingHandler(handler);\n    } else {\n      this.makeActive(handler, event);\n    }\n  }\n\n  private cleanupAwaitingHandlers(handler: GestureHandler): void {\n    for (let i = 0; i < this.awaitingHandlers.length; ++i) {\n      if (\n        !this.awaitingHandlers[i].isAwaiting() &&\n        this.shouldHandlerWaitForOther(this.awaitingHandlers[i], handler)\n      ) {\n        this.cleanHandler(this.awaitingHandlers[i]);\n        this.awaitingHandlers.splice(i, 1);\n      }\n    }\n  }\n\n  public onHandlerStateChange(\n    handler: GestureHandler,\n    newState: State,\n    oldState: State,\n    event: AdaptedPointerEvent\n  ): void {\n    this.handlingChangeSemaphore += 1;\n\n    if (this.isFinished(newState)) {\n      this.awaitingHandlers.forEach((otherHandler) => {\n        if (this.shouldHandlerWaitForOther(otherHandler, handler)) {\n          if (newState === State.END) {\n            otherHandler?.cancel(event);\n            otherHandler?.setAwaiting(false);\n          } else {\n            this.tryActivate(otherHandler, event);\n          }\n        }\n      });\n    }\n\n    if (newState === State.ACTIVE) {\n      this.tryActivate(handler, event);\n    } else if (oldState === State.ACTIVE || oldState === State.END) {\n      if (handler.isActive()) {\n        handler.sendEvent(event, newState, oldState);\n      } else if (oldState === State.ACTIVE) {\n        handler.sendEvent(event, newState, State.BEGAN);\n      }\n    } else if (\n      oldState !== State.UNDETERMINED ||\n      newState !== State.CANCELLED\n    ) {\n      handler.sendEvent(event, newState, oldState);\n    }\n\n    this.handlingChangeSemaphore -= 1;\n\n    this.scheduleFinishedHandlersCleanup();\n\n    if (this.awaitingHandlers.indexOf(handler) < 0) {\n      this.cleanupAwaitingHandlers(handler);\n    }\n  }\n\n  private makeActive(\n    handler: GestureHandler,\n    event: AdaptedPointerEvent\n  ): void {\n    const currentState = handler.getState();\n\n    handler.setActive(true);\n    handler.setShouldResetProgress(true);\n    handler.setActivationIndex(this.activationIndex++);\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      // Order of arguments is correct - we check whether current handler should cancel existing handlers\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        this.handlersToCancel.push(otherHandler);\n      }\n    });\n\n    for (let i = this.handlersToCancel.length - 1; i >= 0; --i) {\n      this.handlersToCancel[i]?.cancel(event);\n    }\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (this.shouldHandlerBeCancelledBy(otherHandler, handler)) {\n        otherHandler?.cancel(event);\n        otherHandler?.setAwaiting(true);\n      }\n    });\n\n    handler.sendEvent(event, State.ACTIVE, State.BEGAN);\n\n    if (currentState !== State.ACTIVE) {\n      handler.sendEvent(event, State.END, State.ACTIVE);\n      if (currentState !== State.END) {\n        handler.sendEvent(event, State.UNDETERMINED, State.END);\n      }\n    }\n\n    if (handler.isAwaiting()) {\n      handler.setAwaiting(false);\n      handler.end(event);\n    }\n\n    this.handlersToCancel = [];\n  }\n\n  private addAwaitingHandler(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.awaitingHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.awaitingHandlers.push(handler);\n\n    handler.setAwaiting(true);\n    handler.setActivationIndex(this.activationIndex++);\n  }\n\n  public recordHandlerIfNotPresent(handler: GestureHandler): void {\n    let alreadyExists = false;\n\n    this.gestureHandlers.forEach((otherHandler) => {\n      if (otherHandler === handler) {\n        alreadyExists = true;\n        return;\n      }\n    });\n\n    if (alreadyExists) {\n      return;\n    }\n\n    this.gestureHandlers.push(handler);\n\n    handler.setActive(false);\n    handler.setAwaiting(false);\n    handler.setActivationIndex(Number.MAX_SAFE_INTEGER);\n  }\n\n  private shouldHandlerWaitForOther(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    return (\n      handler !== otherHandler &&\n      (handler.shouldWaitForHandlerFailure(otherHandler) ||\n        otherHandler.shouldRequireToWaitForFailure(handler))\n    );\n  }\n\n  private canRunSimultaneously(\n    gh1: GestureHandler,\n    gh2: GestureHandler\n  ): boolean {\n    return (\n      gh1 === gh2 ||\n      gh1.shouldRecognizeSimultaneously(gh2) ||\n      gh2.shouldRecognizeSimultaneously(gh1)\n    );\n  }\n\n  private shouldHandlerBeCancelledBy(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    if (\n      !PointerTracker.shareCommonPointers(handlerPointers, otherPointers) &&\n      handler.getView() !== otherHandler.getView()\n    ) {\n      return this.checkOverlap(handler, otherHandler);\n    }\n\n    if (this.canRunSimultaneously(handler, otherHandler)) {\n      return false;\n    }\n\n    if (\n      handler !== otherHandler &&\n      (handler.isAwaiting() || handler.getState() === State.ACTIVE)\n    ) {\n      // For now it always returns false\n      return handler.shouldBeCancelledByOther(otherHandler);\n    }\n\n    return true;\n  }\n\n  private checkOverlap(\n    handler: GestureHandler,\n    otherHandler: GestureHandler\n  ): boolean {\n    // If handlers don't have common pointers, default return value is false.\n    // However, if at least on pointer overlaps with both handlers, we return true\n    // This solves issue in overlapping parents example\n\n    // TODO: Find better way to handle that issue, for example by activation order and handler cancelling\n\n    const handlerPointers: number[] = handler.getTrackedPointersID();\n    const otherPointers: number[] = otherHandler.getTrackedPointersID();\n\n    let overlap = false;\n\n    handlerPointers.forEach((pointer: number) => {\n      const handlerX: number = handler.getTracker().getLastX(pointer);\n      const handlerY: number = handler.getTracker().getLastY(pointer);\n\n      if (\n        handler\n          .getEventManager()\n          .isPointerInBounds({ x: handlerX, y: handlerY }) &&\n        otherHandler\n          .getEventManager()\n          .isPointerInBounds({ x: handlerX, y: handlerY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    otherPointers.forEach((pointer: number) => {\n      const otherX: number = otherHandler.getTracker().getLastX(pointer);\n      const otherY: number = otherHandler.getTracker().getLastY(pointer);\n\n      if (\n        handler.getEventManager().isPointerInBounds({ x: otherX, y: otherY }) &&\n        otherHandler\n          .getEventManager()\n          .isPointerInBounds({ x: otherX, y: otherY })\n      ) {\n        overlap = true;\n      }\n    });\n\n    return overlap;\n  }\n\n  private isFinished(state: State): boolean {\n    return (\n      state === State.END || state === State.FAILED || state === State.CANCELLED\n    );\n  }\n\n  public static getInstance(): GestureHandlerOrchestrator {\n    if (!GestureHandlerOrchestrator.instance)\n      GestureHandlerOrchestrator.instance = new GestureHandlerOrchestrator();\n\n    return GestureHandlerOrchestrator.instance;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}