{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { EventTypes } from \"../interfaces\";\n\nvar RotationGestureDetector = function () {\n  function RotationGestureDetector(callbacks) {\n    _classCallCheck(this, RotationGestureDetector);\n\n    _defineProperty(this, \"onRotationBegin\", void 0);\n\n    _defineProperty(this, \"onRotation\", void 0);\n\n    _defineProperty(this, \"onRotationEnd\", void 0);\n\n    _defineProperty(this, \"currentTime\", 0);\n\n    _defineProperty(this, \"previousTime\", 0);\n\n    _defineProperty(this, \"previousAngle\", 0);\n\n    _defineProperty(this, \"rotation\", 0);\n\n    _defineProperty(this, \"anchorX\", 0);\n\n    _defineProperty(this, \"anchorY\", 0);\n\n    _defineProperty(this, \"isInProgress\", false);\n\n    _defineProperty(this, \"keyPointers\", [NaN, NaN]);\n\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n\n  _createClass(RotationGestureDetector, [{\n    key: \"updateCurrent\",\n    value: function updateCurrent(event, tracker) {\n      this.previousTime = this.currentTime;\n      this.currentTime = event.time;\n\n      var _this$keyPointers = _slicedToArray(this.keyPointers, 2),\n          firstPointerID = _this$keyPointers[0],\n          secondPointerID = _this$keyPointers[1];\n\n      var firstPointerX = tracker.getLastX(firstPointerID);\n      var firstPointerY = tracker.getLastY(firstPointerID);\n      var secondPointerX = tracker.getLastX(secondPointerID);\n      var secondPointerY = tracker.getLastY(secondPointerID);\n      var vectorX = secondPointerX - firstPointerX;\n      var vectorY = secondPointerY - firstPointerY;\n      this.anchorX = (firstPointerX + secondPointerX) / 2;\n      this.anchorY = (firstPointerY + secondPointerY) / 2;\n      var angle = -Math.atan2(vectorY, vectorX);\n      this.rotation = Number.isNaN(this.previousAngle) ? 0 : this.previousAngle - angle;\n      this.previousAngle = angle;\n\n      if (this.rotation > Math.PI) {\n        this.rotation -= Math.PI;\n      } else if (this.rotation < -Math.PI) {\n        this.rotation += Math.PI;\n      }\n\n      if (this.rotation > Math.PI / 2) {\n        this.rotation -= Math.PI;\n      } else if (this.rotation < -Math.PI / 2) {\n        this.rotation += Math.PI;\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish(event) {\n      if (!this.isInProgress) {\n        return;\n      }\n\n      this.isInProgress = false;\n      this.keyPointers = [NaN, NaN];\n      this.onRotationEnd(this, event);\n    }\n  }, {\n    key: \"setKeyPointers\",\n    value: function setKeyPointers(tracker) {\n      if (this.keyPointers[0] && this.keyPointers[1]) {\n        return;\n      }\n\n      var pointerIDs = tracker.getData().keys();\n      this.keyPointers[0] = pointerIDs.next().value;\n      this.keyPointers[1] = pointerIDs.next().value;\n    }\n  }, {\n    key: \"onTouchEvent\",\n    value: function onTouchEvent(event, tracker) {\n      this.adaptEvent(event, tracker);\n\n      switch (event.eventType) {\n        case EventTypes.DOWN:\n          this.isInProgress = false;\n          break;\n\n        case EventTypes.ADDITIONAL_POINTER_DOWN:\n          if (this.isInProgress) {\n            break;\n          }\n\n          this.isInProgress = true;\n          this.previousTime = event.time;\n          this.previousAngle = NaN;\n          this.setKeyPointers(tracker);\n          this.updateCurrent(event, tracker);\n          this.onRotationBegin(this);\n          break;\n\n        case EventTypes.MOVE:\n          if (!this.isInProgress) {\n            break;\n          }\n\n          this.updateCurrent(event, tracker);\n          this.onRotation(this, event);\n          break;\n\n        case EventTypes.ADDITIONAL_POINTER_UP:\n          if (!this.isInProgress) {\n            break;\n          }\n\n          if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n            this.finish(event);\n          }\n\n          break;\n\n        case EventTypes.UP:\n          this.finish(event);\n          break;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"adaptEvent\",\n    value: function adaptEvent(event, tracker) {\n      if (tracker.getTrackedPointersCount() && event.eventType === EventTypes.DOWN) {\n        event.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n      }\n\n      if (tracker.getTrackedPointersCount() > 1 && event.eventType === EventTypes.UP) {\n        event.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n      }\n    }\n  }, {\n    key: \"getTimeDelta\",\n    value: function getTimeDelta() {\n      return this.currentTime + this.previousTime;\n    }\n  }, {\n    key: \"getAnchorX\",\n    value: function getAnchorX() {\n      return this.anchorX;\n    }\n  }, {\n    key: \"getAnchorY\",\n    value: function getAnchorY() {\n      return this.anchorY;\n    }\n  }, {\n    key: \"getRotation\",\n    value: function getRotation() {\n      return this.rotation;\n    }\n  }]);\n\n  return RotationGestureDetector;\n}();\n\nexport { RotationGestureDetector as default };","map":{"version":3,"mappings":"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","names":["EventTypes","RotationGestureDetector","constructor","callbacks","_defineProperty","NaN","onRotationBegin","onRotation","onRotationEnd","updateCurrent","event","tracker","previousTime","currentTime","time","keyPointers","firstPointerID","secondPointerID","firstPointerX","getLastX","firstPointerY","getLastY","secondPointerX","secondPointerY","vectorX","vectorY","anchorX","anchorY","angle","Math","atan2","rotation","Number","isNaN","previousAngle","PI","finish","isInProgress","setKeyPointers","pointerIDs","getData","keys","next","value","onTouchEvent","adaptEvent","eventType","DOWN","ADDITIONAL_POINTER_DOWN","MOVE","ADDITIONAL_POINTER_UP","indexOf","pointerId","UP","getTrackedPointersCount","getTimeDelta","getAnchorX","getAnchorY","getRotation"],"sources":["RotationGestureDetector.ts"],"sourcesContent":["import { AdaptedPointerEvent, EventTypes } from '../interfaces';\nimport PointerTracker from '../tools/PointerTracker';\n\nexport interface RotationGestureListener {\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (\n    detector: RotationGestureDetector,\n    event: AdaptedPointerEvent\n  ) => boolean;\n  onRotationEnd: (\n    detector: RotationGestureDetector,\n    event: AdaptedPointerEvent\n  ) => void;\n}\n\nexport default class RotationGestureDetector\n  implements RotationGestureListener {\n  onRotationBegin: (detector: RotationGestureDetector) => boolean;\n  onRotation: (\n    detector: RotationGestureDetector,\n    event: AdaptedPointerEvent\n  ) => boolean;\n  onRotationEnd: (\n    detector: RotationGestureDetector,\n    event: AdaptedPointerEvent\n  ) => void;\n\n  private currentTime = 0;\n  private previousTime = 0;\n\n  private previousAngle = 0;\n  private rotation = 0;\n\n  private anchorX = 0;\n  private anchorY = 0;\n\n  private isInProgress = false;\n\n  private keyPointers: number[] = [NaN, NaN];\n\n  constructor(callbacks: RotationGestureListener) {\n    this.onRotationBegin = callbacks.onRotationBegin;\n    this.onRotation = callbacks.onRotation;\n    this.onRotationEnd = callbacks.onRotationEnd;\n  }\n\n  private updateCurrent(\n    event: AdaptedPointerEvent,\n    tracker: PointerTracker\n  ): void {\n    this.previousTime = this.currentTime;\n    this.currentTime = event.time;\n\n    const [firstPointerID, secondPointerID] = this.keyPointers;\n\n    const firstPointerX: number = tracker.getLastX(firstPointerID);\n    const firstPointerY: number = tracker.getLastY(firstPointerID);\n    const secondPointerX: number = tracker.getLastX(secondPointerID);\n    const secondPointerY: number = tracker.getLastY(secondPointerID);\n\n    const vectorX: number = secondPointerX - firstPointerX;\n    const vectorY: number = secondPointerY - firstPointerY;\n\n    this.anchorX = (firstPointerX + secondPointerX) / 2;\n    this.anchorY = (firstPointerY + secondPointerY) / 2;\n\n    //Angle diff should be positive when rotating in clockwise direction\n    const angle: number = -Math.atan2(vectorY, vectorX);\n    this.rotation = Number.isNaN(this.previousAngle)\n      ? 0\n      : this.previousAngle - angle;\n\n    this.previousAngle = angle;\n\n    if (this.rotation > Math.PI) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI) {\n      this.rotation += Math.PI;\n    }\n\n    if (this.rotation > Math.PI / 2) {\n      this.rotation -= Math.PI;\n    } else if (this.rotation < -Math.PI / 2) {\n      this.rotation += Math.PI;\n    }\n  }\n\n  private finish(event: AdaptedPointerEvent): void {\n    if (!this.isInProgress) {\n      return;\n    }\n\n    this.isInProgress = false;\n    this.keyPointers = [NaN, NaN];\n    this.onRotationEnd(this, event);\n  }\n\n  private setKeyPointers(tracker: PointerTracker): void {\n    if (this.keyPointers[0] && this.keyPointers[1]) {\n      return;\n    }\n\n    const pointerIDs: IterableIterator<number> = tracker.getData().keys();\n\n    this.keyPointers[0] = pointerIDs.next().value as number;\n    this.keyPointers[1] = pointerIDs.next().value as number;\n  }\n\n  public onTouchEvent(\n    event: AdaptedPointerEvent,\n    tracker: PointerTracker\n  ): boolean {\n    this.adaptEvent(event, tracker);\n\n    switch (event.eventType) {\n      case EventTypes.DOWN:\n        this.isInProgress = false;\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_DOWN:\n        if (this.isInProgress) {\n          break;\n        }\n\n        this.isInProgress = true;\n\n        this.previousTime = event.time;\n        this.previousAngle = NaN;\n\n        this.setKeyPointers(tracker);\n\n        this.updateCurrent(event, tracker);\n        this.onRotationBegin(this);\n        break;\n\n      case EventTypes.MOVE:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        this.updateCurrent(event, tracker);\n        this.onRotation(this, event);\n\n        break;\n\n      case EventTypes.ADDITIONAL_POINTER_UP:\n        if (!this.isInProgress) {\n          break;\n        }\n\n        if (this.keyPointers.indexOf(event.pointerId) >= 0) {\n          this.finish(event);\n        }\n\n        break;\n\n      case EventTypes.UP:\n        this.finish(event);\n        break;\n    }\n\n    return true;\n  }\n\n  private adaptEvent(\n    event: AdaptedPointerEvent,\n    tracker: PointerTracker\n  ): void {\n    if (\n      tracker.getTrackedPointersCount() &&\n      event.eventType === EventTypes.DOWN\n    ) {\n      event.eventType = EventTypes.ADDITIONAL_POINTER_DOWN;\n    }\n\n    if (\n      tracker.getTrackedPointersCount() > 1 &&\n      event.eventType === EventTypes.UP\n    ) {\n      event.eventType = EventTypes.ADDITIONAL_POINTER_UP;\n    }\n  }\n\n  public getTimeDelta(): number {\n    return this.currentTime + this.previousTime;\n  }\n\n  public getAnchorX(): number {\n    return this.anchorX;\n  }\n\n  public getAnchorY(): number {\n    return this.anchorY;\n  }\n\n  public getRotation(): number {\n    return this.rotation;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}