{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty2 from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar _excluded = [\"enabled\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport { State } from \"../../State\";\nimport EventManager from \"../tools/EventManager\";\nimport GestureHandlerOrchestrator from \"../tools/GestureHandlerOrchestrator\";\nimport PointerTracker from \"../tools/PointerTracker\";\n\nvar GestureHandler = function () {\n  function GestureHandler() {\n    var _this = this;\n\n    _classCallCheck(this, GestureHandler);\n\n    _defineProperty(this, \"lastSentState\", null);\n\n    _defineProperty(this, \"currentState\", State.UNDETERMINED);\n\n    _defineProperty(this, \"shouldCancellWhenOutside\", false);\n\n    _defineProperty(this, \"hasCustomActivationCriteria\", void 0);\n\n    _defineProperty(this, \"enabled\", false);\n\n    _defineProperty(this, \"ref\", void 0);\n\n    _defineProperty(this, \"propsRef\", void 0);\n\n    _defineProperty(this, \"config\", {\n      enabled: false\n    });\n\n    _defineProperty(this, \"handlerTag\", void 0);\n\n    _defineProperty(this, \"view\", null);\n\n    _defineProperty(this, \"eventManager\", void 0);\n\n    _defineProperty(this, \"tracker\", new PointerTracker());\n\n    _defineProperty(this, \"interactionManager\", void 0);\n\n    _defineProperty(this, \"activationIndex\", 0);\n\n    _defineProperty(this, \"awaiting\", false);\n\n    _defineProperty(this, \"active\", false);\n\n    _defineProperty(this, \"shouldResetProgress\", false);\n\n    _defineProperty(this, \"sendEvent\", function (event, newState, oldState) {\n      var _this$propsRef$curren = _this.propsRef.current,\n          onGestureHandlerEvent = _this$propsRef$curren.onGestureHandlerEvent,\n          onGestureHandlerStateChange = _this$propsRef$curren.onGestureHandlerStateChange;\n\n      var resultEvent = _this.transformEventData(event, newState, oldState);\n\n      if (_this.lastSentState !== newState) {\n        _this.lastSentState = newState;\n        invokeNullableMethod(onGestureHandlerStateChange, resultEvent);\n      }\n\n      if (_this.currentState === State.ACTIVE) {\n        resultEvent.nativeEvent.oldState = undefined;\n        invokeNullableMethod(onGestureHandlerEvent, resultEvent);\n      }\n    });\n\n    this.hasCustomActivationCriteria = false;\n  }\n\n  _createClass(GestureHandler, [{\n    key: \"init\",\n    value: function init(ref, propsRef) {\n      this.propsRef = propsRef;\n      this.ref = ref;\n      this.currentState = State.UNDETERMINED;\n      this.setView(ref);\n      this.setEventManager();\n    }\n  }, {\n    key: \"setView\",\n    value: function setView(ref) {\n      if (!ref) {\n        this.view = null;\n        return;\n      }\n\n      this.view = findNodeHandle(ref);\n      this.view.style['touchAction'] = 'none';\n      this.view.style['webkitUserSelect'] = 'none';\n      this.view.style['userSelect'] = 'none';\n      this.view.style['WebkitTouchCallout'] = 'none';\n    }\n  }, {\n    key: \"setEventManager\",\n    value: function setEventManager() {\n      if (!this.view) {\n        return;\n      }\n\n      this.eventManager = new EventManager(this.view);\n      this.eventManager.setOnPointerDown(this.onPointerDown.bind(this));\n      this.eventManager.setOnPointerUp(this.onPointerUp.bind(this));\n      this.eventManager.setOnPointerMove(this.onPointerMove.bind(this));\n      this.eventManager.setOnPointerEnter(this.onPointerEnter.bind(this));\n      this.eventManager.setOnPointerOut(this.onPointerOut.bind(this));\n      this.eventManager.setOnPointerCancel(this.onPointerCancel.bind(this));\n      this.eventManager.setOnPointerOutOfBounds(this.onPointerOutOfBounds.bind(this));\n      this.eventManager.setListeners();\n    }\n  }, {\n    key: \"setInteractionManager\",\n    value: function setInteractionManager(manager) {\n      this.interactionManager = manager;\n    }\n  }, {\n    key: \"onCancel\",\n    value: function onCancel() {}\n  }, {\n    key: \"onReset\",\n    value: function onReset() {}\n  }, {\n    key: \"resetProgress\",\n    value: function resetProgress() {}\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.tracker.resetTracker();\n      this.onReset();\n      this.currentState = State.UNDETERMINED;\n    }\n  }, {\n    key: \"moveToState\",\n    value: function moveToState(newState, event) {\n      if (this.currentState === newState) {\n        return;\n      }\n\n      var oldState = this.currentState;\n      this.currentState = newState;\n      GestureHandlerOrchestrator.getInstance().onHandlerStateChange(this, newState, oldState, event);\n      this.onStateChange(newState, oldState);\n    }\n  }, {\n    key: \"onStateChange\",\n    value: function onStateChange(_newState, _oldState) {}\n  }, {\n    key: \"begin\",\n    value: function begin(event) {\n      if (!this.checkHitSlop(event)) {\n        return;\n      }\n\n      if (this.currentState === State.UNDETERMINED) {\n        this.moveToState(State.BEGAN, event);\n      }\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(event) {\n      if (this.currentState === State.ACTIVE || this.currentState === State.BEGAN) {\n        this.moveToState(State.FAILED, event);\n      }\n\n      this.resetProgress();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(event) {\n      if (this.currentState === State.ACTIVE || this.currentState === State.UNDETERMINED || this.currentState === State.BEGAN) {\n        this.onCancel();\n        this.moveToState(State.CANCELLED, event);\n      }\n    }\n  }, {\n    key: \"activate\",\n    value: function activate(event) {\n      var _force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.currentState === State.UNDETERMINED || this.currentState === State.BEGAN) {\n        this.moveToState(State.ACTIVE, event);\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(event) {\n      if (this.currentState === State.BEGAN || this.currentState === State.ACTIVE) {\n        this.moveToState(State.END, event);\n      }\n\n      this.resetProgress();\n    }\n  }, {\n    key: \"isAwaiting\",\n    value: function isAwaiting() {\n      return this.awaiting;\n    }\n  }, {\n    key: \"setAwaiting\",\n    value: function setAwaiting(value) {\n      this.awaiting = value;\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this.active;\n    }\n  }, {\n    key: \"setActive\",\n    value: function setActive(value) {\n      this.active = value;\n    }\n  }, {\n    key: \"getShouldResetProgress\",\n    value: function getShouldResetProgress() {\n      return this.shouldResetProgress;\n    }\n  }, {\n    key: \"setShouldResetProgress\",\n    value: function setShouldResetProgress(value) {\n      this.shouldResetProgress = value;\n    }\n  }, {\n    key: \"getActivationIndex\",\n    value: function getActivationIndex() {\n      return this.activationIndex;\n    }\n  }, {\n    key: \"setActivationIndex\",\n    value: function setActivationIndex(value) {\n      this.activationIndex = value;\n    }\n  }, {\n    key: \"shouldWaitForHandlerFailure\",\n    value: function shouldWaitForHandlerFailure(handler) {\n      if (handler === this) {\n        return false;\n      }\n\n      return this.interactionManager.shouldWaitForHandlerFailure(this, handler);\n    }\n  }, {\n    key: \"shouldRequireToWaitForFailure\",\n    value: function shouldRequireToWaitForFailure(handler) {\n      if (handler === this) {\n        return false;\n      }\n\n      return this.interactionManager.shouldRequireHandlerToWaitForFailure(this, handler);\n    }\n  }, {\n    key: \"shouldRecognizeSimultaneously\",\n    value: function shouldRecognizeSimultaneously(handler) {\n      if (handler === this) {\n        return true;\n      }\n\n      return this.interactionManager.shouldRecognizeSimultaneously(this, handler);\n    }\n  }, {\n    key: \"shouldBeCancelledByOther\",\n    value: function shouldBeCancelledByOther(handler) {\n      if (handler === this) {\n        return false;\n      }\n\n      return this.interactionManager.shouldHandlerBeCancelledBy(this, handler);\n    }\n  }, {\n    key: \"onPointerDown\",\n    value: function onPointerDown(_event) {\n      GestureHandlerOrchestrator.getInstance().recordHandlerIfNotPresent(this);\n    }\n  }, {\n    key: \"onPointerAdd\",\n    value: function onPointerAdd(_event) {}\n  }, {\n    key: \"onPointerUp\",\n    value: function onPointerUp(_event) {}\n  }, {\n    key: \"onPointerRemove\",\n    value: function onPointerRemove(_event) {}\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(event) {\n      this.tryToSendMoveEvent(event, false);\n    }\n  }, {\n    key: \"onPointerOut\",\n    value: function onPointerOut(_event) {}\n  }, {\n    key: \"onPointerEnter\",\n    value: function onPointerEnter(_event) {}\n  }, {\n    key: \"onPointerCancel\",\n    value: function onPointerCancel(_event) {}\n  }, {\n    key: \"onPointerOutOfBounds\",\n    value: function onPointerOutOfBounds(event) {\n      this.tryToSendMoveEvent(event, true);\n    }\n  }, {\n    key: \"tryToSendMoveEvent\",\n    value: function tryToSendMoveEvent(event, out) {\n      if (this.currentState === State.ACTIVE && (!out || out && !this.shouldCancellWhenOutside)) {\n        this.sendEvent(event, this.currentState, this.currentState);\n      }\n    }\n  }, {\n    key: \"transformEventData\",\n    value: function transformEventData(event, newState, oldState) {\n      var _this$eventManager;\n\n      return {\n        nativeEvent: _objectSpread(_objectSpread({\n          numberOfPointers: this.tracker.getTrackedPointersCount(),\n          state: newState,\n          pointerInside: (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.isPointerInBounds({\n            x: event.x,\n            y: event.y\n          })\n        }, this.transformNativeEvent(event)), {}, {\n          handlerTag: this.handlerTag,\n          target: this.ref,\n          oldState: newState !== oldState ? oldState : undefined\n        }),\n        timeStamp: Date.now()\n      };\n    }\n  }, {\n    key: \"transformNativeEvent\",\n    value: function transformNativeEvent(_event) {\n      return {};\n    }\n  }, {\n    key: \"updateGestureConfig\",\n    value: function updateGestureConfig(_ref) {\n      var _ref$enabled = _ref.enabled,\n          enabled = _ref$enabled === void 0 ? true : _ref$enabled,\n          props = _objectWithoutProperties(_ref, _excluded);\n\n      this.config = _objectSpread({\n        enabled: enabled\n      }, props);\n      this.validateHitSlops();\n    }\n  }, {\n    key: \"checkCustomActivationCriteria\",\n    value: function checkCustomActivationCriteria(criterias) {\n      for (var key in this.config) {\n        if (criterias.indexOf(key) >= 0) {\n          this.hasCustomActivationCriteria = true;\n        }\n      }\n    }\n  }, {\n    key: \"validateHitSlops\",\n    value: function validateHitSlops() {\n      if (!this.config.hitSlop) {\n        return;\n      }\n\n      if (this.config.hitSlop.left !== undefined && this.config.hitSlop.right !== undefined && this.config.hitSlop.width !== undefined) {\n        throw new Error('HitSlop Error: Cannot define left, right and width at the same time');\n      }\n\n      if (this.config.hitSlop.width !== undefined && this.config.hitSlop.left === undefined && this.config.hitSlop.right === undefined) {\n        throw new Error('HitSlop Error: When width is defined, either left or right has to be defined');\n      }\n\n      if (this.config.hitSlop.height !== undefined && this.config.hitSlop.top !== undefined && this.config.hitSlop.bottom !== undefined) {\n        throw new Error('HitSlop Error: Cannot define top, bottom and height at the same time');\n      }\n\n      if (this.config.hitSlop.height !== undefined && this.config.hitSlop.top === undefined && this.config.hitSlop.bottom === undefined) {\n        throw new Error('HitSlop Error: When height is defined, either top or bottom has to be defined');\n      }\n    }\n  }, {\n    key: \"checkHitSlop\",\n    value: function checkHitSlop(event) {\n      if (!this.config.hitSlop || !this.view) {\n        return true;\n      }\n\n      var width = this.view.getBoundingClientRect().width;\n      var height = this.view.getBoundingClientRect().height;\n      var left = 0;\n      var top = 0;\n      var right = width;\n      var bottom = height;\n\n      if (this.config.hitSlop.horizontal !== undefined) {\n        left -= this.config.hitSlop.horizontal;\n        right += this.config.hitSlop.horizontal;\n      }\n\n      if (this.config.hitSlop.vertical !== undefined) {\n        top -= this.config.hitSlop.vertical;\n        bottom += this.config.hitSlop.vertical;\n      }\n\n      if (this.config.hitSlop.left !== undefined) {\n        left = -this.config.hitSlop.left;\n      }\n\n      if (this.config.hitSlop.right !== undefined) {\n        right = width + this.config.hitSlop.right;\n      }\n\n      if (this.config.hitSlop.top !== undefined) {\n        top = -this.config.hitSlop.top;\n      }\n\n      if (this.config.hitSlop.bottom !== undefined) {\n        bottom = width + this.config.hitSlop.bottom;\n      }\n\n      if (this.config.hitSlop.width !== undefined) {\n        if (this.config.hitSlop.left !== undefined) {\n          right = left + this.config.hitSlop.width;\n        } else if (this.config.hitSlop.right !== undefined) {\n          left = right - this.config.hitSlop.width;\n        }\n      }\n\n      if (this.config.hitSlop.height !== undefined) {\n        if (this.config.hitSlop.top !== undefined) {\n          bottom = top + this.config.hitSlop.height;\n        } else if (this.config.hitSlop.bottom !== undefined) {\n          top = bottom - this.config.hitSlop.height;\n        }\n      }\n\n      if (event.offsetX >= left && event.offsetX <= right && event.offsetY >= top && event.offsetY <= bottom) {\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"resetConfig\",\n    value: function resetConfig() {}\n  }, {\n    key: \"getTag\",\n    value: function getTag() {\n      return this.handlerTag;\n    }\n  }, {\n    key: \"setTag\",\n    value: function setTag(tag) {\n      this.handlerTag = tag;\n    }\n  }, {\n    key: \"getConfig\",\n    value: function getConfig() {\n      return this.config;\n    }\n  }, {\n    key: \"getShouldEnableGestureOnSetup\",\n    value: function getShouldEnableGestureOnSetup() {\n      throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\n    }\n  }, {\n    key: \"getView\",\n    value: function getView() {\n      return this.view;\n    }\n  }, {\n    key: \"getEventManager\",\n    value: function getEventManager() {\n      return this.eventManager;\n    }\n  }, {\n    key: \"getTracker\",\n    value: function getTracker() {\n      return this.tracker;\n    }\n  }, {\n    key: \"getTrackedPointersID\",\n    value: function getTrackedPointersID() {\n      return this.tracker.getTrackedPointersID();\n    }\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return this.currentState;\n    }\n  }, {\n    key: \"setShouldCancelWhenOutside\",\n    value: function setShouldCancelWhenOutside(flag) {\n      this.shouldCancellWhenOutside = flag;\n    }\n  }, {\n    key: \"getShouldCancelWhenOutside\",\n    value: function getShouldCancelWhenOutside() {\n      return this.shouldCancellWhenOutside;\n    }\n  }]);\n\n  return GestureHandler;\n}();\n\nexport { GestureHandler as default };\n\nfunction invokeNullableMethod(method, event) {\n  if (!method) {\n    return;\n  }\n\n  if (typeof method === 'function') {\n    method(event);\n    return;\n  }\n\n  if ('__getHandler' in method && typeof method.__getHandler === 'function') {\n    var handler = method.__getHandler();\n\n    invokeNullableMethod(handler, event);\n    return;\n  }\n\n  if (!('__nodeConfig' in method)) {\n    return;\n  }\n\n  var argMapping = method.__nodeConfig.argMapping;\n\n  if (!Array.isArray(argMapping)) {\n    return;\n  }\n\n  for (var _ref2 of argMapping.entries()) {\n    var _ref3 = _slicedToArray(_ref2, 2);\n\n    var index = _ref3[0];\n\n    var _ref3$ = _slicedToArray(_ref3[1], 2);\n\n    var key = _ref3$[0];\n    var value = _ref3$[1];\n\n    if (!(key in event.nativeEvent)) {\n      continue;\n    }\n\n    var nativeValue = event.nativeEvent[key];\n\n    if (value !== null && value !== void 0 && value.setValue) {\n      value.setValue(nativeValue);\n    } else {\n      method.__nodeConfig.argMapping[index] = [key, nativeValue];\n    }\n  }\n\n  return;\n}","map":{"version":3,"mappings":"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","names":["State","EventManager","GestureHandlerOrchestrator","PointerTracker","GestureHandler","constructor","_defineProperty","UNDETERMINED","enabled","event","newState","oldState","propsRef","current","onGestureHandlerEvent","onGestureHandlerStateChange","resultEvent","transformEventData","lastSentState","invokeNullableMethod","currentState","ACTIVE","nativeEvent","undefined","hasCustomActivationCriteria","init","ref","setView","setEventManager","view","findNodeHandle","style","eventManager","setOnPointerDown","onPointerDown","bind","setOnPointerUp","onPointerUp","setOnPointerMove","onPointerMove","setOnPointerEnter","onPointerEnter","setOnPointerOut","onPointerOut","setOnPointerCancel","onPointerCancel","setOnPointerOutOfBounds","onPointerOutOfBounds","setListeners","setInteractionManager","manager","interactionManager","onCancel","onReset","resetProgress","reset","tracker","resetTracker","moveToState","getInstance","onHandlerStateChange","onStateChange","_newState","_oldState","begin","checkHitSlop","BEGAN","fail","FAILED","cancel","CANCELLED","activate","_force","end","END","isAwaiting","awaiting","setAwaiting","value","isActive","active","setActive","getShouldResetProgress","shouldResetProgress","setShouldResetProgress","getActivationIndex","activationIndex","setActivationIndex","shouldWaitForHandlerFailure","handler","shouldRequireToWaitForFailure","shouldRequireHandlerToWaitForFailure","shouldRecognizeSimultaneously","shouldBeCancelledByOther","shouldHandlerBeCancelledBy","_event","recordHandlerIfNotPresent","onPointerAdd","onPointerRemove","tryToSendMoveEvent","out","shouldCancellWhenOutside","sendEvent","numberOfPointers","getTrackedPointersCount","state","pointerInside","_this$eventManager","isPointerInBounds","x","y","transformNativeEvent","handlerTag","target","timeStamp","Date","now","updateGestureConfig","props","config","validateHitSlops","checkCustomActivationCriteria","criterias","key","indexOf","hitSlop","left","right","width","Error","height","top","bottom","getBoundingClientRect","horizontal","vertical","offsetX","offsetY","resetConfig","getTag","setTag","tag","getConfig","getShouldEnableGestureOnSetup","getView","getEventManager","getTracker","getTrackedPointersID","getState","setShouldCancelWhenOutside","flag","getShouldCancelWhenOutside","method","__getHandler","argMapping","__nodeConfig","Array","isArray","entries","index","nativeValue","setValue"],"sources":["GestureHandler.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport { findNodeHandle } from 'react-native';\nimport { State } from '../../State';\nimport {\n  Config,\n  AdaptedPointerEvent,\n  PropsRef,\n  ResultEvent,\n} from '../interfaces';\nimport EventManager from '../tools/EventManager';\nimport GestureHandlerOrchestrator from '../tools/GestureHandlerOrchestrator';\nimport InteractionManager from '../tools/InteractionManager';\nimport PointerTracker from '../tools/PointerTracker';\n\nexport default abstract class GestureHandler {\n  private lastSentState: State | null = null;\n  protected currentState: State = State.UNDETERMINED;\n\n  protected shouldCancellWhenOutside = false;\n  protected hasCustomActivationCriteria: boolean;\n  protected enabled = false;\n\n  private ref!: number;\n  private propsRef!: React.RefObject<unknown>;\n  protected config: Config = { enabled: false };\n  private handlerTag!: number;\n  protected view: HTMLElement | null = null;\n\n  protected eventManager!: EventManager;\n  protected tracker: PointerTracker = new PointerTracker();\n  protected interactionManager!: InteractionManager;\n\n  // Orchestrator properties\n  protected activationIndex = 0;\n  protected awaiting = false;\n  protected active = false;\n  protected shouldResetProgress = false;\n\n  public constructor() {\n    this.hasCustomActivationCriteria = false;\n  }\n\n  //\n  // Initializing handler\n  //\n\n  protected init(ref: number, propsRef: React.RefObject<unknown>) {\n    this.propsRef = propsRef;\n    this.ref = ref;\n\n    this.currentState = State.UNDETERMINED;\n\n    this.setView(ref);\n    this.setEventManager();\n  }\n\n  private setView(ref: number) {\n    if (!ref) {\n      this.view = null;\n      return;\n    }\n\n    this.view = (findNodeHandle(ref) as unknown) as HTMLElement;\n    this.view.style['touchAction'] = 'none';\n    this.view.style['webkitUserSelect'] = 'none';\n    this.view.style['userSelect'] = 'none';\n\n    //@ts-ignore This one disables default events on Safari\n    this.view.style['WebkitTouchCallout'] = 'none';\n  }\n\n  private setEventManager(): void {\n    if (!this.view) {\n      return;\n    }\n\n    this.eventManager = new EventManager(this.view);\n\n    this.eventManager.setOnPointerDown(this.onPointerDown.bind(this));\n    this.eventManager.setOnPointerUp(this.onPointerUp.bind(this));\n    this.eventManager.setOnPointerMove(this.onPointerMove.bind(this));\n    this.eventManager.setOnPointerEnter(this.onPointerEnter.bind(this));\n    this.eventManager.setOnPointerOut(this.onPointerOut.bind(this));\n    this.eventManager.setOnPointerCancel(this.onPointerCancel.bind(this));\n    this.eventManager.setOnPointerOutOfBounds(\n      this.onPointerOutOfBounds.bind(this)\n    );\n\n    this.eventManager.setListeners();\n  }\n\n  public setInteractionManager(manager: InteractionManager): void {\n    this.interactionManager = manager;\n  }\n\n  //\n  // Resetting handler\n  //\n\n  protected onCancel(): void {}\n  protected onReset(): void {}\n  protected resetProgress(): void {}\n\n  public reset(): void {\n    this.tracker.resetTracker();\n    this.onReset();\n    this.currentState = State.UNDETERMINED;\n  }\n\n  //\n  // State logic\n  //\n\n  public moveToState(newState: State, event: AdaptedPointerEvent) {\n    if (this.currentState === newState) {\n      return;\n    }\n\n    const oldState = this.currentState;\n    this.currentState = newState;\n\n    GestureHandlerOrchestrator.getInstance().onHandlerStateChange(\n      this,\n      newState,\n      oldState,\n      event\n    );\n\n    this.onStateChange(newState, oldState);\n  }\n\n  protected onStateChange(_newState: State, _oldState: State): void {}\n\n  public begin(event: AdaptedPointerEvent): void {\n    if (!this.checkHitSlop(event)) {\n      return;\n    }\n\n    if (this.currentState === State.UNDETERMINED) {\n      this.moveToState(State.BEGAN, event);\n    }\n  }\n\n  public fail(event: AdaptedPointerEvent): void {\n    if (\n      this.currentState === State.ACTIVE ||\n      this.currentState === State.BEGAN\n    ) {\n      this.moveToState(State.FAILED, event);\n    }\n\n    this.resetProgress();\n  }\n\n  public cancel(event: AdaptedPointerEvent): void {\n    if (\n      this.currentState === State.ACTIVE ||\n      this.currentState === State.UNDETERMINED ||\n      this.currentState === State.BEGAN\n    ) {\n      this.onCancel();\n      this.moveToState(State.CANCELLED, event);\n    }\n  }\n\n  protected activate(event: AdaptedPointerEvent, _force = false) {\n    if (\n      this.currentState === State.UNDETERMINED ||\n      this.currentState === State.BEGAN\n    ) {\n      this.moveToState(State.ACTIVE, event);\n    }\n  }\n\n  public end(event: AdaptedPointerEvent) {\n    if (\n      this.currentState === State.BEGAN ||\n      this.currentState === State.ACTIVE\n    ) {\n      this.moveToState(State.END, event);\n    }\n\n    this.resetProgress();\n  }\n\n  //\n  // Methods for orchestrator\n  //\n\n  public isAwaiting(): boolean {\n    return this.awaiting;\n  }\n  public setAwaiting(value: boolean): void {\n    this.awaiting = value;\n  }\n\n  public isActive(): boolean {\n    return this.active;\n  }\n  public setActive(value: boolean): void {\n    this.active = value;\n  }\n\n  public getShouldResetProgress(): boolean {\n    return this.shouldResetProgress;\n  }\n  public setShouldResetProgress(value: boolean): void {\n    this.shouldResetProgress = value;\n  }\n\n  public getActivationIndex(): number {\n    return this.activationIndex;\n  }\n  public setActivationIndex(value: number): void {\n    this.activationIndex = value;\n  }\n\n  public shouldWaitForHandlerFailure(handler: GestureHandler): boolean {\n    if (handler === this) {\n      return false;\n    }\n\n    return this.interactionManager.shouldWaitForHandlerFailure(this, handler);\n  }\n\n  public shouldRequireToWaitForFailure(handler: GestureHandler): boolean {\n    if (handler === this) {\n      return false;\n    }\n\n    return this.interactionManager.shouldRequireHandlerToWaitForFailure(\n      this,\n      handler\n    );\n  }\n\n  public shouldRecognizeSimultaneously(handler: GestureHandler): boolean {\n    if (handler === this) {\n      return true;\n    }\n\n    return this.interactionManager.shouldRecognizeSimultaneously(this, handler);\n  }\n\n  public shouldBeCancelledByOther(handler: GestureHandler): boolean {\n    if (handler === this) {\n      return false;\n    }\n\n    return this.interactionManager.shouldHandlerBeCancelledBy(this, handler);\n  }\n\n  //\n  // Event actions\n  //\n\n  protected onPointerDown(_event: AdaptedPointerEvent): void {\n    GestureHandlerOrchestrator.getInstance().recordHandlerIfNotPresent(this);\n  }\n  // Adding another pointer to existing ones\n  protected onPointerAdd(_event: AdaptedPointerEvent): void {}\n  protected onPointerUp(_event: AdaptedPointerEvent): void {}\n  // Removing pointer, when there is more than one pointers\n  protected onPointerRemove(_event: AdaptedPointerEvent): void {}\n  protected onPointerMove(event: AdaptedPointerEvent): void {\n    this.tryToSendMoveEvent(event, false);\n  }\n  protected onPointerOut(_event: AdaptedPointerEvent): void {}\n  protected onPointerEnter(_event: AdaptedPointerEvent): void {}\n  protected onPointerCancel(_event: AdaptedPointerEvent): void {}\n  protected onPointerOutOfBounds(event: AdaptedPointerEvent): void {\n    this.tryToSendMoveEvent(event, true);\n  }\n  private tryToSendMoveEvent(event: AdaptedPointerEvent, out: boolean): void {\n    if (\n      this.currentState === State.ACTIVE &&\n      (!out || (out && !this.shouldCancellWhenOutside))\n    ) {\n      this.sendEvent(event, this.currentState, this.currentState);\n    }\n  }\n\n  //\n  // Events Sending\n  //\n\n  public sendEvent = (\n    event: AdaptedPointerEvent,\n    newState: State,\n    oldState: State\n  ): void => {\n    const {\n      onGestureHandlerEvent,\n      onGestureHandlerStateChange,\n    }: PropsRef = this.propsRef.current as PropsRef;\n\n    const resultEvent: ResultEvent = this.transformEventData(\n      event,\n      newState,\n      oldState\n    );\n\n    // In the new API oldState field has to be undefined, unless we send event state changed\n    // Here the order is flipped to avoid workarounds such as making backup of the state and setting it to undefined first, then changing it back\n    // Flipping order with setting oldState to undefined solves issue, when events were being sent twice instead of once\n    // However, this may cause trouble in the future (but for now we don't know that)\n\n    if (this.lastSentState !== newState) {\n      this.lastSentState = newState;\n      invokeNullableMethod(onGestureHandlerStateChange, resultEvent);\n    }\n    if (this.currentState === State.ACTIVE) {\n      resultEvent.nativeEvent.oldState = undefined;\n      invokeNullableMethod(onGestureHandlerEvent, resultEvent);\n    }\n  };\n\n  private transformEventData(\n    event: AdaptedPointerEvent,\n    newState: State,\n    oldState: State\n  ): ResultEvent {\n    return {\n      nativeEvent: {\n        numberOfPointers: this.tracker.getTrackedPointersCount(),\n        state: newState,\n        pointerInside: this.eventManager?.isPointerInBounds({\n          x: event.x,\n          y: event.y,\n        }),\n        ...this.transformNativeEvent(event),\n        handlerTag: this.handlerTag,\n        target: this.ref,\n        oldState: newState !== oldState ? oldState : undefined,\n      },\n      timeStamp: Date.now(),\n    };\n  }\n\n  protected transformNativeEvent(_event: AdaptedPointerEvent) {\n    return {};\n  }\n\n  //\n  // Handling config\n  //\n\n  public updateGestureConfig({ enabled = true, ...props }): void {\n    this.config = { enabled, ...props };\n    this.validateHitSlops();\n  }\n\n  protected checkCustomActivationCriteria(criterias: string[]): void {\n    for (const key in this.config) {\n      if (criterias.indexOf(key) >= 0) {\n        this.hasCustomActivationCriteria = true;\n      }\n    }\n  }\n\n  private validateHitSlops(): void {\n    if (!this.config.hitSlop) {\n      return;\n    }\n\n    if (\n      this.config.hitSlop.left !== undefined &&\n      this.config.hitSlop.right !== undefined &&\n      this.config.hitSlop.width !== undefined\n    ) {\n      throw new Error(\n        'HitSlop Error: Cannot define left, right and width at the same time'\n      );\n    }\n\n    if (\n      this.config.hitSlop.width !== undefined &&\n      this.config.hitSlop.left === undefined &&\n      this.config.hitSlop.right === undefined\n    ) {\n      throw new Error(\n        'HitSlop Error: When width is defined, either left or right has to be defined'\n      );\n    }\n\n    if (\n      this.config.hitSlop.height !== undefined &&\n      this.config.hitSlop.top !== undefined &&\n      this.config.hitSlop.bottom !== undefined\n    ) {\n      throw new Error(\n        'HitSlop Error: Cannot define top, bottom and height at the same time'\n      );\n    }\n\n    if (\n      this.config.hitSlop.height !== undefined &&\n      this.config.hitSlop.top === undefined &&\n      this.config.hitSlop.bottom === undefined\n    ) {\n      throw new Error(\n        'HitSlop Error: When height is defined, either top or bottom has to be defined'\n      );\n    }\n  }\n\n  private checkHitSlop(event: AdaptedPointerEvent): boolean {\n    if (!this.config.hitSlop || !this.view) {\n      return true;\n    }\n\n    const width = this.view.getBoundingClientRect().width;\n    const height = this.view.getBoundingClientRect().height;\n\n    let left = 0;\n    let top = 0;\n    let right: number = width;\n    let bottom: number = height;\n\n    if (this.config.hitSlop.horizontal !== undefined) {\n      left -= this.config.hitSlop.horizontal;\n      right += this.config.hitSlop.horizontal;\n    }\n\n    if (this.config.hitSlop.vertical !== undefined) {\n      top -= this.config.hitSlop.vertical;\n      bottom += this.config.hitSlop.vertical;\n    }\n\n    if (this.config.hitSlop.left !== undefined) {\n      left = -this.config.hitSlop.left;\n    }\n\n    if (this.config.hitSlop.right !== undefined) {\n      right = width + this.config.hitSlop.right;\n    }\n\n    if (this.config.hitSlop.top !== undefined) {\n      top = -this.config.hitSlop.top;\n    }\n\n    if (this.config.hitSlop.bottom !== undefined) {\n      bottom = width + this.config.hitSlop.bottom;\n    }\n    if (this.config.hitSlop.width !== undefined) {\n      if (this.config.hitSlop.left !== undefined) {\n        right = left + this.config.hitSlop.width;\n      } else if (this.config.hitSlop.right !== undefined) {\n        left = right - this.config.hitSlop.width;\n      }\n    }\n\n    if (this.config.hitSlop.height !== undefined) {\n      if (this.config.hitSlop.top !== undefined) {\n        bottom = top + this.config.hitSlop.height;\n      } else if (this.config.hitSlop.bottom !== undefined) {\n        top = bottom - this.config.hitSlop.height;\n      }\n    }\n\n    if (\n      event.offsetX >= left &&\n      event.offsetX <= right &&\n      event.offsetY >= top &&\n      event.offsetY <= bottom\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  protected resetConfig(): void {}\n\n  //\n  // Getters and setters\n  //\n\n  public getTag(): number {\n    return this.handlerTag;\n  }\n  public setTag(tag: number): void {\n    this.handlerTag = tag;\n  }\n\n  protected getConfig() {\n    return this.config;\n  }\n\n  public getShouldEnableGestureOnSetup(): boolean {\n    throw new Error('Must override GestureHandler.shouldEnableGestureOnSetup');\n  }\n\n  public getView(): HTMLElement | null {\n    return this.view;\n  }\n\n  public getEventManager(): EventManager {\n    return this.eventManager;\n  }\n\n  public getTracker(): PointerTracker {\n    return this.tracker;\n  }\n\n  public getTrackedPointersID(): number[] {\n    return this.tracker.getTrackedPointersID();\n  }\n\n  public getState(): State {\n    return this.currentState;\n  }\n\n  protected setShouldCancelWhenOutside(flag: boolean) {\n    this.shouldCancellWhenOutside = flag;\n  }\n  protected getShouldCancelWhenOutside(): boolean {\n    return this.shouldCancellWhenOutside;\n  }\n}\n\nfunction invokeNullableMethod(\n  method:\n    | ((event: ResultEvent) => void)\n    | { __getHandler: () => (event: ResultEvent) => void }\n    | { __nodeConfig: { argMapping: unknown[] } },\n  event: ResultEvent\n): void {\n  if (!method) {\n    return;\n  }\n\n  if (typeof method === 'function') {\n    method(event);\n    return;\n  }\n\n  if ('__getHandler' in method && typeof method.__getHandler === 'function') {\n    const handler = method.__getHandler();\n    invokeNullableMethod(handler, event);\n    return;\n  }\n\n  if (!('__nodeConfig' in method)) {\n    return;\n  }\n\n  const { argMapping } = method.__nodeConfig;\n  if (!Array.isArray(argMapping)) {\n    return;\n  }\n\n  for (const [index, [key, value]] of argMapping.entries()) {\n    if (!(key in event.nativeEvent)) {\n      continue;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const nativeValue = event.nativeEvent[key];\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    if (value?.setValue) {\n      //Reanimated API\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n      value.setValue(nativeValue);\n    } else {\n      //RN Animated API\n      method.__nodeConfig.argMapping[index] = [key, nativeValue];\n    }\n  }\n\n  return;\n}\n"]},"metadata":{},"sourceType":"module"}