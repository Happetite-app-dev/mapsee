{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport { computeNextBackoffInterval } from '@ide/backoff';\nimport * as Application from 'expo-application';\nimport { CodedError, Platform, UnavailabilityError } from 'expo-modules-core';\nimport ServerRegistrationModule from \"../ServerRegistrationModule\";\nvar updateDevicePushTokenUrl = 'https://exp.host/--/api/v2/push/updateDeviceToken';\nexport function updateDevicePushTokenAsync(_x, _x2) {\n  return _updateDevicePushTokenAsync.apply(this, arguments);\n}\n\nfunction _updateDevicePushTokenAsync() {\n  _updateDevicePushTokenAsync = _asyncToGenerator(function* (signal, token) {\n    var doUpdateDevicePushTokenAsync = function () {\n      var _ref = _asyncToGenerator(function* (retry) {\n        var _yield$Promise$all = yield Promise.all([shouldUseDevelopmentNotificationService(), getDeviceIdAsync()]),\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2),\n            development = _yield$Promise$all2[0],\n            deviceId = _yield$Promise$all2[1];\n\n        var body = {\n          deviceId: deviceId.toLowerCase(),\n          development: development,\n          deviceToken: token.data,\n          appId: Application.applicationId,\n          type: getTypeOfToken(token)\n        };\n\n        try {\n          var response = yield fetch(updateDevicePushTokenUrl, {\n            method: 'POST',\n            headers: {\n              'content-type': 'application/json'\n            },\n            body: JSON.stringify(body),\n            signal: signal\n          });\n\n          if (!response.ok) {\n            console.debug('[expo-notifications] Error encountered while updating the device push token with the server:', yield response.text());\n          }\n\n          if (!response.ok) {\n            retry();\n          }\n        } catch (e) {\n          if (e.name === 'AbortError') {\n            return;\n          }\n\n          console.warn('[expo-notifications] Error thrown while updating the device push token with the server:', e);\n          retry();\n        }\n      });\n\n      return function doUpdateDevicePushTokenAsync(_x3) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    var shouldTry = true;\n\n    var retry = function retry() {\n      shouldTry = true;\n    };\n\n    var retriesCount = 0;\n    var initialBackoff = 500;\n    var backoffOptions = {\n      maxBackoff: 2 * 60 * 1000\n    };\n    var nextBackoffInterval = computeNextBackoffInterval(initialBackoff, retriesCount, backoffOptions);\n\n    while (shouldTry && !signal.aborted) {\n      shouldTry = false;\n      yield doUpdateDevicePushTokenAsync(retry);\n\n      if (shouldTry && !signal.aborted) {\n        nextBackoffInterval = computeNextBackoffInterval(initialBackoff, retriesCount, backoffOptions);\n        retriesCount += 1;\n        yield new Promise(function (resolve) {\n          return setTimeout(resolve, nextBackoffInterval);\n        });\n      }\n    }\n  });\n  return _updateDevicePushTokenAsync.apply(this, arguments);\n}\n\nfunction getDeviceIdAsync() {\n  return _getDeviceIdAsync.apply(this, arguments);\n}\n\nfunction _getDeviceIdAsync() {\n  _getDeviceIdAsync = _asyncToGenerator(function* () {\n    try {\n      if (!ServerRegistrationModule.getInstallationIdAsync) {\n        throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n      }\n\n      return yield ServerRegistrationModule.getInstallationIdAsync();\n    } catch (e) {\n      throw new CodedError('ERR_NOTIFICATIONS_DEVICE_ID', \"Could not fetch the installation ID of the application: \" + e + \".\");\n    }\n  });\n  return _getDeviceIdAsync.apply(this, arguments);\n}\n\nfunction getTypeOfToken(devicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n\n    case 'android':\n      return 'fcm';\n\n    default:\n      return devicePushToken.type;\n  }\n}\n\nfunction shouldUseDevelopmentNotificationService() {\n  return _shouldUseDevelopmentNotificationService.apply(this, arguments);\n}\n\nfunction _shouldUseDevelopmentNotificationService() {\n  _shouldUseDevelopmentNotificationService = _asyncToGenerator(function* () {\n    if (Platform.OS === 'ios') {\n      try {\n        var notificationServiceEnvironment = yield Application.getIosPushNotificationServiceEnvironmentAsync();\n\n        if (notificationServiceEnvironment === 'development') {\n          return true;\n        }\n      } catch (_unused) {}\n    }\n\n    return false;\n  });\n  return _shouldUseDevelopmentNotificationService.apply(this, arguments);\n}","map":{"version":3,"mappings":"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","names":["computeNextBackoffInterval","Application","CodedError","Platform","UnavailabilityError","ServerRegistrationModule","updateDevicePushTokenUrl","updateDevicePushTokenAsync","signal","token","doUpdateDevicePushTokenAsync","retry","Promise","all","shouldUseDevelopmentNotificationService","getDeviceIdAsync","development","deviceId","body","toLowerCase","deviceToken","data","appId","applicationId","type","getTypeOfToken","response","fetch","method","headers","JSON","stringify","ok","console","debug","text","e","name","warn","shouldTry","retriesCount","initialBackoff","backoffOptions","maxBackoff","nextBackoffInterval","aborted","resolve","setTimeout","getInstallationIdAsync","devicePushToken","OS","notificationServiceEnvironment","getIosPushNotificationServiceEnvironmentAsync"],"sourceRoot":"","sources":["../../src/utils/updateDevicePushTokenAsync.ts"],"sourcesContent":["import { computeNextBackoffInterval } from '@ide/backoff';\nimport * as Application from 'expo-application';\nimport { CodedError, Platform, UnavailabilityError } from 'expo-modules-core';\n\nimport ServerRegistrationModule from '../ServerRegistrationModule';\nimport { DevicePushToken } from '../Tokens.types';\n\nconst updateDevicePushTokenUrl = 'https://exp.host/--/api/v2/push/updateDeviceToken';\n\nexport async function updateDevicePushTokenAsync(signal: AbortSignal, token: DevicePushToken) {\n  const doUpdateDevicePushTokenAsync = async (retry: () => void) => {\n    const [development, deviceId] = await Promise.all([\n      shouldUseDevelopmentNotificationService(),\n      getDeviceIdAsync(),\n    ]);\n    const body = {\n      deviceId: deviceId.toLowerCase(),\n      development,\n      deviceToken: token.data,\n      appId: Application.applicationId,\n      type: getTypeOfToken(token),\n    };\n\n    try {\n      const response = await fetch(updateDevicePushTokenUrl, {\n        method: 'POST',\n        headers: {\n          'content-type': 'application/json',\n        },\n        body: JSON.stringify(body),\n        signal,\n      });\n\n      // Help debug erroring servers\n      if (!response.ok) {\n        console.debug(\n          '[expo-notifications] Error encountered while updating the device push token with the server:',\n          await response.text()\n        );\n      }\n\n      // Retry if request failed\n      if (!response.ok) {\n        retry();\n      }\n    } catch (e) {\n      // Error returned if the request is aborted should be an 'AbortError'. In\n      // React Native fetch is polyfilled using `whatwg-fetch` which:\n      // - creates `AbortError`s like this\n      //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L505\n      // - which creates exceptions like\n      //   https://github.com/github/fetch/blob/75d9455d380f365701151f3ac85c5bda4bbbde76/fetch.js#L490-L494\n      if (e.name === 'AbortError') {\n        // We don't consider AbortError a failure, it's a sign somewhere else the\n        // request is expected to succeed and we don't need this one, so let's\n        // just return.\n        return;\n      }\n\n      console.warn(\n        '[expo-notifications] Error thrown while updating the device push token with the server:',\n        e\n      );\n\n      retry();\n    }\n  };\n\n  let shouldTry = true;\n  const retry = () => {\n    shouldTry = true;\n  };\n\n  let retriesCount = 0;\n  const initialBackoff = 500; // 0.5 s\n  const backoffOptions = {\n    maxBackoff: 2 * 60 * 1000, // 2 minutes\n  };\n  let nextBackoffInterval = computeNextBackoffInterval(\n    initialBackoff,\n    retriesCount,\n    backoffOptions\n  );\n\n  while (shouldTry && !signal.aborted) {\n    // Will be set to true by `retry` if it's called\n    shouldTry = false;\n    await doUpdateDevicePushTokenAsync(retry);\n\n    // Do not wait if we won't retry\n    if (shouldTry && !signal.aborted) {\n      nextBackoffInterval = computeNextBackoffInterval(\n        initialBackoff,\n        retriesCount,\n        backoffOptions\n      );\n      retriesCount += 1;\n      await new Promise((resolve) => setTimeout(resolve, nextBackoffInterval));\n    }\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_DEVICE_ID',\n      `Could not fetch the installation ID of the application: ${e}.`\n    );\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n\n// Same as in getExpoPushTokenAsync\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment =\n        await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}