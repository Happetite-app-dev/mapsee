{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport Marker from \"./MapMarker\";\nimport Polyline from \"./MapPolyline\";\nimport Polygon from \"./MapPolygon\";\nimport { ColorPropType } from 'deprecated-react-native-prop-types';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar propTypes = {\n  geojson: PropTypes.object.isRequired,\n  strokeColor: ColorPropType,\n  fillColor: ColorPropType,\n  strokeWidth: PropTypes.number,\n  lineDashPhase: PropTypes.number,\n  tappable: PropTypes.bool,\n  lineDashPattern: PropTypes.arrayOf(PropTypes.number),\n  lineCap: PropTypes.oneOf(['butt', 'round', 'square']),\n  lineJoin: PropTypes.oneOf(['miter', 'round', 'bevel']),\n  miterLimit: PropTypes.number,\n  zIndex: PropTypes.number,\n  onPress: PropTypes.func,\n  markerComponent: PropTypes.node,\n  title: PropTypes.string\n};\n\nvar Geojson = function Geojson(props) {\n  var title = props.title,\n      image = props.image,\n      zIndex = props.zIndex,\n      _onPress = props.onPress,\n      lineCap = props.lineCap,\n      lineJoin = props.lineJoin,\n      tappable = props.tappable,\n      miterLimit = props.miterLimit,\n      lineDashPhase = props.lineDashPhase,\n      lineDashPattern = props.lineDashPattern,\n      markerComponent = props.markerComponent;\n  var overlays = makeOverlays(props.geojson.features);\n  return _jsx(React.Fragment, {\n    children: overlays.map(function (overlay, index) {\n      var fillColor = getColor(props, overlay, 'fill', 'fillColor');\n      var strokeColor = getColor(props, overlay, 'stroke', 'strokeColor');\n      var markerColor = getColor(props, overlay, 'marker-color', 'color');\n      var strokeWidth = getStrokeWidth(props, overlay);\n\n      if (overlay.type === 'point') {\n        return _jsx(Marker, {\n          coordinate: overlay.coordinates,\n          image: image,\n          title: title,\n          pinColor: markerColor,\n          zIndex: zIndex,\n          onPress: function onPress() {\n            return _onPress && _onPress(overlay);\n          },\n          children: markerComponent\n        }, index);\n      }\n\n      if (overlay.type === 'polygon') {\n        return _jsx(Polygon, {\n          coordinates: overlay.coordinates,\n          holes: overlay.holes,\n          strokeColor: strokeColor,\n          fillColor: fillColor,\n          strokeWidth: strokeWidth,\n          tappable: tappable,\n          onPress: function onPress() {\n            return _onPress && _onPress(overlay);\n          },\n          zIndex: zIndex\n        }, index);\n      }\n\n      if (overlay.type === 'polyline') {\n        return _jsx(Polyline, {\n          coordinates: overlay.coordinates,\n          strokeColor: strokeColor,\n          strokeWidth: strokeWidth,\n          lineDashPhase: lineDashPhase,\n          lineDashPattern: lineDashPattern,\n          lineCap: lineCap,\n          lineJoin: lineJoin,\n          miterLimit: miterLimit,\n          zIndex: zIndex,\n          tappable: tappable,\n          onPress: function onPress() {\n            return _onPress && _onPress(overlay);\n          }\n        }, index);\n      }\n    })\n  });\n};\n\nGeojson.propTypes = propTypes;\nexport default Geojson;\nexport var makeOverlays = function makeOverlays(features) {\n  var points = features.filter(function (f) {\n    return f.geometry && (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint');\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'point'\n    });\n  });\n  var lines = features.filter(function (f) {\n    return f.geometry && (f.geometry.type === 'LineString' || f.geometry.type === 'MultiLineString');\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polyline'\n    });\n  });\n  var multipolygons = features.filter(function (f) {\n    return f.geometry && f.geometry.type === 'MultiPolygon';\n  }).map(function (feature) {\n    return makeCoordinates(feature).map(function (coordinates) {\n      return makeOverlay(coordinates, feature);\n    });\n  }).reduce(flatten, []);\n  var polygons = features.filter(function (f) {\n    return f.geometry && f.geometry.type === 'Polygon';\n  }).map(function (feature) {\n    return makeOverlay(makeCoordinates(feature), feature);\n  }).reduce(flatten, []).concat(multipolygons).map(function (overlay) {\n    return _objectSpread(_objectSpread({}, overlay), {}, {\n      type: 'polygon'\n    });\n  });\n  return points.concat(lines).concat(polygons);\n};\n\nvar flatten = function flatten(prev, curr) {\n  return prev.concat(curr);\n};\n\nvar makeOverlay = function makeOverlay(coordinates, feature) {\n  var overlay = {\n    feature: feature\n  };\n\n  if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {\n    overlay.coordinates = coordinates[0];\n\n    if (coordinates.length > 1) {\n      overlay.holes = coordinates.slice(1);\n    }\n  } else {\n    overlay.coordinates = coordinates;\n  }\n\n  return overlay;\n};\n\nvar makePoint = function makePoint(c) {\n  return {\n    latitude: c[1],\n    longitude: c[0]\n  };\n};\n\nvar makeLine = function makeLine(l) {\n  return l.map(makePoint);\n};\n\nvar makeCoordinates = function makeCoordinates(feature) {\n  var g = feature.geometry;\n\n  if (g.type === 'Point') {\n    return [makePoint(g.coordinates)];\n  } else if (g.type === 'MultiPoint') {\n    return g.coordinates.map(makePoint);\n  } else if (g.type === 'LineString') {\n    return [makeLine(g.coordinates)];\n  } else if (g.type === 'MultiLineString') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'Polygon') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'MultiPolygon') {\n    return g.coordinates.map(function (p) {\n      return p.map(makeLine);\n    });\n  } else {\n    return [];\n  }\n};\n\nvar doesOverlayContainProperty = function doesOverlayContainProperty(overlay, property) {\n  return overlay.feature && overlay.feature.properties && overlay.feature.properties[property];\n};\n\nvar getRgbaFromHex = function getRgbaFromHex(hex) {\n  var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  var _hex$match$map = hex.match(/\\w\\w/g).map(function (x) {\n    return parseInt(x, 16);\n  }),\n      _hex$match$map2 = _slicedToArray(_hex$match$map, 3),\n      r = _hex$match$map2[0],\n      g = _hex$match$map2[1],\n      b = _hex$match$map2[2];\n\n  return \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + alpha + \")\";\n};\n\nvar getColor = function getColor(props, overlay, colorType, overrideColorProp) {\n  if (props.hasOwnProperty(overrideColorProp)) {\n    return props[overrideColorProp];\n  }\n\n  if (doesOverlayContainProperty(overlay, colorType)) {\n    var color = overlay.feature.properties[colorType];\n    var opacityProperty = colorType + '-opacity';\n\n    if (doesOverlayContainProperty(overlay, opacityProperty) && color[0] === '#') {\n      color = getRgbaFromHex(color, overlay.feature.properties[opacityProperty]);\n    }\n\n    return color;\n  }\n\n  return;\n};\n\nvar getStrokeWidth = function getStrokeWidth(props, overlay) {\n  if (props.hasOwnProperty('strokeWidth')) {\n    return props.strokeWidth;\n  }\n\n  if (doesOverlayContainProperty(overlay, 'stroke-width')) {\n    return overlay.feature.properties['stroke-width'];\n  }\n\n  return;\n};","map":{"version":3,"names":["React","PropTypes","Marker","Polyline","Polygon","ColorPropType","propTypes","geojson","object","isRequired","strokeColor","fillColor","strokeWidth","number","lineDashPhase","tappable","bool","lineDashPattern","arrayOf","lineCap","oneOf","lineJoin","miterLimit","zIndex","onPress","func","markerComponent","node","title","string","Geojson","props","image","overlays","makeOverlays","features","map","overlay","index","getColor","markerColor","getStrokeWidth","type","coordinates","holes","points","filter","f","geometry","feature","makeCoordinates","makeOverlay","reduce","flatten","lines","multipolygons","polygons","concat","prev","curr","length","slice","makePoint","c","latitude","longitude","makeLine","l","g","p","doesOverlayContainProperty","property","properties","getRgbaFromHex","hex","alpha","match","x","parseInt","r","b","colorType","overrideColorProp","hasOwnProperty","color","opacityProperty"],"sources":["/Users/jeongin/mapsee_2/node_modules/react-native-maps/src/Geojson.js"],"sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\nimport Marker from './MapMarker';\nimport Polyline from './MapPolyline';\nimport Polygon from './MapPolygon';\nimport { ColorPropType } from 'deprecated-react-native-prop-types';\n\nconst propTypes = {\n  /**\n   * [Geojson](https://geojson.org/) description of object.\n   */\n  geojson: PropTypes.object.isRequired,\n\n  /**\n   * The stroke color to use for the path.\n   */\n  strokeColor: ColorPropType,\n\n  /**\n   * The fill color to use for the path.\n   */\n  fillColor: ColorPropType,\n\n  /**\n   * The stroke width to use for the path.\n   */\n  strokeWidth: PropTypes.number,\n\n  /**\n   * The offset (in points) at which to start drawing the dash pattern.\n   *\n   * Use this property to start drawing a dashed line partway through a segment or gap. For\n   * example, a phase value of 6 for the patter 5-2-3-2 would cause drawing to begin in the\n   * middle of the first gap.\n   *\n   * The default value of this property is 0.\n   *\n   * @platform ios\n   */\n  lineDashPhase: PropTypes.number,\n\n  /**\n   * Make the `Polygon` or `Polyline` tappable\n   *\n   */\n  tappable: PropTypes.bool,\n\n  /**\n   * An array of numbers specifying the dash pattern to use for the path.\n   *\n   * The array contains one or more numbers that indicate the lengths (measured in points) of the\n   * line segments and gaps in the pattern. The values in the array alternate, starting with the\n   * first line segment length, followed by the first gap length, followed by the second line\n   * segment length, and so on.\n   *\n   * This property is set to `null` by default, which indicates no line dash pattern.\n   *\n   * @platform ios\n   */\n  lineDashPattern: PropTypes.arrayOf(PropTypes.number),\n\n  /**\n   * The line cap style to apply to the open ends of the path.\n   * The default style is `round`.\n   *\n   * @platform ios\n   */\n  lineCap: PropTypes.oneOf(['butt', 'round', 'square']),\n\n  /**\n   * The line join style to apply to corners of the path.\n   * The default style is `round`.\n   *\n   * @platform ios\n   */\n  lineJoin: PropTypes.oneOf(['miter', 'round', 'bevel']),\n\n  /**\n   * The limiting value that helps avoid spikes at junctions between connected line segments.\n   * The miter limit helps you avoid spikes in paths that use the `miter` `lineJoin` style. If\n   * the ratio of the miter length—that is, the diagonal length of the miter join—to the line\n   * thickness exceeds the miter limit, the joint is converted to a bevel join. The default\n   * miter limit is 10, which results in the conversion of miters whose angle at the joint\n   * is less than 11 degrees.\n   *\n   * @platform ios\n   */\n  miterLimit: PropTypes.number,\n\n  /**\n   * The order in which this tile overlay is drawn with respect to other overlays. An overlay\n   * with a larger z-index is drawn over overlays with smaller z-indices. The order of overlays\n   * with the same z-index is arbitrary. The default zIndex is 0.\n   *\n   * @platform android\n   */\n  zIndex: PropTypes.number,\n\n  /**\n   * Callback that is called when the user presses on the polygon\n   */\n  onPress: PropTypes.func,\n\n  /**\n   * Component to render in place of the default marker when the overlay type is a `point`\n   *\n   */\n  markerComponent: PropTypes.node,\n\n  /**\n   * The title of the marker. This is only used if the <Marker /> component has no children that\n   * are a `<Callout />`, in which case the default callout behavior will be used, which\n   * will show both the `title` and the `description`, if provided.\n   */\n  title: PropTypes.string,\n};\n\nconst Geojson = (props) => {\n  const {\n    title,\n    image,\n    zIndex,\n    onPress,\n    lineCap,\n    lineJoin,\n    tappable,\n    miterLimit,\n    lineDashPhase,\n    lineDashPattern,\n    markerComponent,\n  } = props;\n  const overlays = makeOverlays(props.geojson.features);\n  return (\n    <React.Fragment>\n      {overlays.map((overlay, index) => {\n        const fillColor = getColor(props, overlay, 'fill', 'fillColor');\n        const strokeColor = getColor(props, overlay, 'stroke', 'strokeColor');\n        const markerColor = getColor(props, overlay, 'marker-color', 'color');\n        const strokeWidth = getStrokeWidth(props, overlay);\n        if (overlay.type === 'point') {\n          return (\n            <Marker\n              key={index}\n              coordinate={overlay.coordinates}\n              image={image}\n              title={title}\n              pinColor={markerColor}\n              zIndex={zIndex}\n              onPress={() => onPress && onPress(overlay)}\n            >\n              {markerComponent}\n            </Marker>\n          );\n        }\n        if (overlay.type === 'polygon') {\n          return (\n            <Polygon\n              key={index}\n              coordinates={overlay.coordinates}\n              holes={overlay.holes}\n              strokeColor={strokeColor}\n              fillColor={fillColor}\n              strokeWidth={strokeWidth}\n              tappable={tappable}\n              onPress={() => onPress && onPress(overlay)}\n              zIndex={zIndex}\n            />\n          );\n        }\n        if (overlay.type === 'polyline') {\n          return (\n            <Polyline\n              key={index}\n              coordinates={overlay.coordinates}\n              strokeColor={strokeColor}\n              strokeWidth={strokeWidth}\n              lineDashPhase={lineDashPhase}\n              lineDashPattern={lineDashPattern}\n              lineCap={lineCap}\n              lineJoin={lineJoin}\n              miterLimit={miterLimit}\n              zIndex={zIndex}\n              tappable={tappable}\n              onPress={() => onPress && onPress(overlay)}\n            />\n          );\n        }\n      })}\n    </React.Fragment>\n  );\n};\n\nGeojson.propTypes = propTypes;\n\nexport default Geojson;\n\nexport const makeOverlays = (features) => {\n  const points = features\n    .filter(\n      (f) =>\n        f.geometry &&\n        (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint')\n    )\n    .map((feature) =>\n      makeCoordinates(feature).map((coordinates) =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, [])\n    .map((overlay) => ({ ...overlay, type: 'point' }));\n\n  const lines = features\n    .filter(\n      (f) =>\n        f.geometry &&\n        (f.geometry.type === 'LineString' ||\n          f.geometry.type === 'MultiLineString')\n    )\n    .map((feature) =>\n      makeCoordinates(feature).map((coordinates) =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, [])\n    .map((overlay) => ({ ...overlay, type: 'polyline' }));\n\n  const multipolygons = features\n    .filter((f) => f.geometry && f.geometry.type === 'MultiPolygon')\n    .map((feature) =>\n      makeCoordinates(feature).map((coordinates) =>\n        makeOverlay(coordinates, feature)\n      )\n    )\n    .reduce(flatten, []);\n\n  const polygons = features\n    .filter((f) => f.geometry && f.geometry.type === 'Polygon')\n    .map((feature) => makeOverlay(makeCoordinates(feature), feature))\n    .reduce(flatten, [])\n    .concat(multipolygons)\n    .map((overlay) => ({ ...overlay, type: 'polygon' }));\n\n  return points.concat(lines).concat(polygons);\n};\n\nconst flatten = (prev, curr) => prev.concat(curr);\n\nconst makeOverlay = (coordinates, feature) => {\n  let overlay = {\n    feature,\n  };\n  if (\n    feature.geometry.type === 'Polygon' ||\n    feature.geometry.type === 'MultiPolygon'\n  ) {\n    overlay.coordinates = coordinates[0];\n    if (coordinates.length > 1) {\n      overlay.holes = coordinates.slice(1);\n    }\n  } else {\n    overlay.coordinates = coordinates;\n  }\n  return overlay;\n};\n\nconst makePoint = (c) => ({ latitude: c[1], longitude: c[0] });\n\nconst makeLine = (l) => l.map(makePoint);\n\nconst makeCoordinates = (feature) => {\n  const g = feature.geometry;\n  if (g.type === 'Point') {\n    return [makePoint(g.coordinates)];\n  } else if (g.type === 'MultiPoint') {\n    return g.coordinates.map(makePoint);\n  } else if (g.type === 'LineString') {\n    return [makeLine(g.coordinates)];\n  } else if (g.type === 'MultiLineString') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'Polygon') {\n    return g.coordinates.map(makeLine);\n  } else if (g.type === 'MultiPolygon') {\n    return g.coordinates.map((p) => p.map(makeLine));\n  } else {\n    return [];\n  }\n};\n\nconst doesOverlayContainProperty = (overlay, property) => {\n  // Geojson may have 0 for the opacity when intention is to not specify the\n  // opacity. Therefore, we evaluate the truthiness of the propery where 0\n  // would return false.\n  return (\n    overlay.feature &&\n    overlay.feature.properties &&\n    overlay.feature.properties[property]\n  );\n};\n\nconst getRgbaFromHex = (hex, alpha = 1) => {\n  const [r, g, b] = hex.match(/\\w\\w/g).map((x) => parseInt(x, 16));\n  return `rgba(${r},${g},${b},${alpha})`;\n};\n\nconst getColor = (props, overlay, colorType, overrideColorProp) => {\n  if (props.hasOwnProperty(overrideColorProp)) {\n    return props[overrideColorProp];\n  }\n  if (doesOverlayContainProperty(overlay, colorType)) {\n    let color = overlay.feature.properties[colorType];\n    const opacityProperty = colorType + '-opacity';\n    if (\n      doesOverlayContainProperty(overlay, opacityProperty) &&\n      color[0] === '#'\n    ) {\n      color = getRgbaFromHex(\n        color,\n        overlay.feature.properties[opacityProperty]\n      );\n    }\n    return color;\n  }\n  return;\n};\n\nconst getStrokeWidth = (props, overlay) => {\n  if (props.hasOwnProperty('strokeWidth')) {\n    return props.strokeWidth;\n  }\n  if (doesOverlayContainProperty(overlay, 'stroke-width')) {\n    return overlay.feature.properties['stroke-width'];\n  }\n  return;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}