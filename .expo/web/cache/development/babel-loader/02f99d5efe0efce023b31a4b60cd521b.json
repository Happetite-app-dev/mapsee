{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { State } from \"../../State\";\nimport GestureHandler from \"./GestureHandler\";\n\nvar NativeViewGestureHandler = function (_GestureHandler) {\n  _inherits(NativeViewGestureHandler, _GestureHandler);\n\n  var _super = _createSuper(NativeViewGestureHandler);\n\n  function NativeViewGestureHandler() {\n    var _this;\n\n    _classCallCheck(this, NativeViewGestureHandler);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"buttonRole\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"disallowInterruption\", false);\n\n    return _this;\n  }\n\n  _createClass(NativeViewGestureHandler, [{\n    key: \"init\",\n    value: function init(ref, propsRef) {\n      _get(_getPrototypeOf(NativeViewGestureHandler.prototype), \"init\", this).call(this, ref, propsRef);\n\n      this.setShouldCancelWhenOutside(true);\n\n      if (!this.view) {\n        return;\n      }\n\n      this.view.style['touchAction'] = 'auto';\n      this.view.style['webkitUserSelect'] = 'auto';\n      this.view.style['userSelect'] = 'auto';\n      this.view.style['WebkitTouchCallout'] = 'auto';\n\n      if (this.view.hasAttribute('role')) {\n        this.buttonRole = true;\n      } else {\n        this.buttonRole = false;\n      }\n    }\n  }, {\n    key: \"resetConfig\",\n    value: function resetConfig() {\n      _get(_getPrototypeOf(NativeViewGestureHandler.prototype), \"resetConfig\", this).call(this);\n    }\n  }, {\n    key: \"onPointerDown\",\n    value: function onPointerDown(event) {\n      _get(_getPrototypeOf(NativeViewGestureHandler.prototype), \"onPointerDown\", this).call(this, event);\n\n      this.tracker.addToTracker(event);\n\n      if (this.currentState === State.UNDETERMINED) {\n        this.begin(event);\n\n        if (this.buttonRole) {\n          this.activate(event);\n        }\n      }\n    }\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(_event) {}\n  }, {\n    key: \"onPointerOut\",\n    value: function onPointerOut(event) {\n      this.cancel(event);\n    }\n  }, {\n    key: \"onPointerUp\",\n    value: function onPointerUp(event) {\n      this.tracker.removeFromTracker(event.pointerId);\n\n      if (!this.buttonRole) {\n        this.activate(event);\n      }\n\n      if (this.tracker.getTrackedPointersCount() === 0) {\n        this.end(event);\n      }\n    }\n  }, {\n    key: \"onPointerCancel\",\n    value: function onPointerCancel(event) {\n      this.cancel(event);\n      this.reset();\n    }\n  }, {\n    key: \"shouldRecognizeSimultaneously\",\n    value: function shouldRecognizeSimultaneously(handler) {\n      if (_get(_getPrototypeOf(NativeViewGestureHandler.prototype), \"shouldRecognizeSimultaneously\", this).call(this, handler)) {\n        return true;\n      }\n\n      if (handler instanceof NativeViewGestureHandler && handler.getState() === State.ACTIVE && handler.disallowsInterruption()) {\n        return false;\n      }\n\n      var canBeInterrupted = !this.disallowInterruption;\n\n      if (this.currentState === State.ACTIVE && handler.getState() === State.ACTIVE && canBeInterrupted) {\n        return false;\n      }\n\n      return this.currentState === State.ACTIVE && canBeInterrupted && handler.getTag() > 0;\n    }\n  }, {\n    key: \"shouldBeCancelledByOther\",\n    value: function shouldBeCancelledByOther(_handler) {\n      return !this.disallowInterruption;\n    }\n  }, {\n    key: \"disallowsInterruption\",\n    value: function disallowsInterruption() {\n      return this.disallowInterruption;\n    }\n  }]);\n\n  return NativeViewGestureHandler;\n}(GestureHandler);\n\nexport { NativeViewGestureHandler as default };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,KAAT;AAGA,OAAOC,cAAP;;IACqBC,wB;;;;;EAAgD;IAAA;;IAAA;;IAAA;MAAAC;IAAA;;IAAA;;IAAAC;;IAAAA,uEAGpC,KAHoC;;IAAA;EAAA;;;;WAK5DC,cAAKC,GAALD,EAAkBE,QAAlBF,EAA4D;MACjE,mFAAWC,GAAX,EAAgBC,QAAhB;;MAEA,KAAKC,0BAAL,CAAgC,IAAhC;;MAEA,IAAI,CAAC,KAAKC,IAAV,EAAgB;QACd;MACD;;MAED,KAAKA,IAAL,CAAUC,KAAV,CAAgB,aAAhB,IAAiC,MAAjC;MACA,KAAKD,IAAL,CAAUC,KAAV,CAAgB,kBAAhB,IAAsC,MAAtC;MACA,KAAKD,IAAL,CAAUC,KAAV,CAAgB,YAAhB,IAAgC,MAAhC;MAGA,KAAKD,IAAL,CAAUC,KAAV,CAAgB,oBAAhB,IAAwC,MAAxC;;MAEA,IAAI,KAAKD,IAAL,CAAUE,YAAV,CAAuB,MAAvB,CAAJ,EAAoC;QAClC,KAAKC,UAAL,GAAkB,IAAlB;MADF,OAEO;QACL,KAAKA,UAAL,GAAkB,KAAlB;MACD;IACF;;;WAESC,uBAAoB;MAC5B;IACD;;;WAESC,uBAAcC,KAAdD,EAAgD;MACxD,4FAAoBC,KAApB;;MACA,KAAKC,OAAL,CAAaC,YAAb,CAA0BF,KAA1B;;MAEA,IAAI,KAAKG,YAAL,KAAsBlB,KAAK,CAACmB,YAAhC,EAA8C;QAC5C,KAAKC,KAAL,CAAWL,KAAX;;QACA,IAAI,KAAKH,UAAT,EAAqB;UACnB,KAAKS,QAAL,CAAcN,KAAd;QACD;MACF;IACF;;;WAESO,uBAAcC,MAAdD,EAAiD,CAE1D;;;WAESE,sBAAaT,KAAbS,EAA+C;MACvD,KAAKC,MAAL,CAAYV,KAAZ;IACD;;;WAESW,qBAAYX,KAAZW,EAA8C;MACtD,KAAKV,OAAL,CAAaW,iBAAb,CAA+BZ,KAAK,CAACa,SAArC;;MACA,IAAI,CAAC,KAAKhB,UAAV,EAAsB;QACpB,KAAKS,QAAL,CAAcN,KAAd;MACD;;MACD,IAAI,KAAKC,OAAL,CAAaa,uBAAb,OAA2C,CAA/C,EAAkD;QAChD,KAAKC,GAAL,CAASf,KAAT;MACD;IACF;;;WAESgB,yBAAgBhB,KAAhBgB,EAAkD;MAC1D,KAAKN,MAAL,CAAYV,KAAZ;MACA,KAAKiB,KAAL;IACD;;;WAEMC,uCAA8BC,OAA9BD,EAAgE;MACrE,gHAAwCC,OAAxC,GAAkD;QAChD,OAAO,IAAP;MACD;;MAED,IACEA,OAAO,YAAYhC,wBAAnBgC,IACAA,OAAO,CAACC,QAARD,OAAuBlC,KAAK,CAACoC,MAD7BF,IAEAA,OAAO,CAACG,qBAARH,EAHF,EAIE;QACA,OAAO,KAAP;MACD;;MAED,IAAMI,gBAAgB,GAAG,CAAC,KAAKC,oBAA/B;;MAEA,IACE,KAAKrB,YAAL,KAAsBlB,KAAK,CAACoC,MAA5B,IACAF,OAAO,CAACC,QAARD,OAAuBlC,KAAK,CAACoC,MAD7B,IAEAE,gBAHF,EAIE;QACA,OAAO,KAAP;MACD;;MAED,OACE,KAAKpB,YAAL,KAAsBlB,KAAK,CAACoC,MAA5B,IACAE,gBADA,IAEAJ,OAAO,CAACM,MAARN,KAAmB,CAHrB;IAKD;;;WAEMO,kCAAyBC,QAAzBD,EAA4D;MACjE,OAAO,CAAC,KAAKF,oBAAb;IACD;;;WAEMF,iCAAiC;MACtC,OAAO,KAAKE,oBAAZ;IACD;;;;EAvGmDtC,c;;SAAjCC,wB","names":["State","GestureHandler","NativeViewGestureHandler","args","_defineProperty","init","ref","propsRef","setShouldCancelWhenOutside","view","style","hasAttribute","buttonRole","resetConfig","onPointerDown","event","tracker","addToTracker","currentState","UNDETERMINED","begin","activate","onPointerMove","_event","onPointerOut","cancel","onPointerUp","removeFromTracker","pointerId","getTrackedPointersCount","end","onPointerCancel","reset","shouldRecognizeSimultaneously","handler","getState","ACTIVE","disallowsInterruption","canBeInterrupted","disallowInterruption","getTag","shouldBeCancelledByOther","_handler"],"sources":["NativeViewGestureHandler.ts"],"sourcesContent":["import { State } from '../../State';\nimport { AdaptedPointerEvent } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\nexport default class NativeViewGestureHandler extends GestureHandler {\n  private buttonRole!: boolean;\n\n  private disallowInterruption = false;\n\n  public init(ref: number, propsRef: React.RefObject<unknown>): void {\n    super.init(ref, propsRef);\n\n    this.setShouldCancelWhenOutside(true);\n\n    if (!this.view) {\n      return;\n    }\n\n    this.view.style['touchAction'] = 'auto';\n    this.view.style['webkitUserSelect'] = 'auto';\n    this.view.style['userSelect'] = 'auto';\n\n    //@ts-ignore Turns on defualt touch behavior on Safari\n    this.view.style['WebkitTouchCallout'] = 'auto';\n\n    if (this.view.hasAttribute('role')) {\n      this.buttonRole = true;\n    } else {\n      this.buttonRole = false;\n    }\n  }\n\n  protected resetConfig(): void {\n    super.resetConfig();\n  }\n\n  protected onPointerDown(event: AdaptedPointerEvent): void {\n    super.onPointerDown(event);\n    this.tracker.addToTracker(event);\n\n    if (this.currentState === State.UNDETERMINED) {\n      this.begin(event);\n      if (this.buttonRole) {\n        this.activate(event);\n      }\n    }\n  }\n\n  protected onPointerMove(_event: AdaptedPointerEvent): void {\n    //\n  }\n\n  protected onPointerOut(event: AdaptedPointerEvent): void {\n    this.cancel(event);\n  }\n\n  protected onPointerUp(event: AdaptedPointerEvent): void {\n    this.tracker.removeFromTracker(event.pointerId);\n    if (!this.buttonRole) {\n      this.activate(event);\n    }\n    if (this.tracker.getTrackedPointersCount() === 0) {\n      this.end(event);\n    }\n  }\n\n  protected onPointerCancel(event: AdaptedPointerEvent): void {\n    this.cancel(event);\n    this.reset();\n  }\n\n  public shouldRecognizeSimultaneously(handler: GestureHandler): boolean {\n    if (super.shouldRecognizeSimultaneously(handler)) {\n      return true;\n    }\n\n    if (\n      handler instanceof NativeViewGestureHandler &&\n      handler.getState() === State.ACTIVE &&\n      handler.disallowsInterruption()\n    ) {\n      return false;\n    }\n\n    const canBeInterrupted = !this.disallowInterruption;\n\n    if (\n      this.currentState === State.ACTIVE &&\n      handler.getState() === State.ACTIVE &&\n      canBeInterrupted\n    ) {\n      return false;\n    }\n\n    return (\n      this.currentState === State.ACTIVE &&\n      canBeInterrupted &&\n      handler.getTag() > 0\n    );\n  }\n\n  public shouldBeCancelledByOther(_handler: GestureHandler): boolean {\n    return !this.disallowInterruption;\n  }\n\n  public disallowsInterruption(): boolean {\n    return this.disallowInterruption;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}