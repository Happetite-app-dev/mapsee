{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport * as Application from 'expo-application';\nimport Constants from 'expo-constants';\nimport { Platform, CodedError, UnavailabilityError } from 'expo-modules-core';\nimport { setAutoServerRegistrationEnabledAsync } from \"./DevicePushTokenAutoRegistration.fx\";\nimport ServerRegistrationModule from \"./ServerRegistrationModule\";\nimport getDevicePushTokenAsync from \"./getDevicePushTokenAsync\";\nvar productionBaseUrl = 'https://exp.host/--/api/v2/';\nexport default function getExpoPushTokenAsync() {\n  return _getExpoPushTokenAsync.apply(this, arguments);\n}\n\nfunction _getExpoPushTokenAsync() {\n  _getExpoPushTokenAsync = _asyncToGenerator(function* () {\n    var _Constants$expoConfig, _Constants$manifest, _Constants$manifest2, _Constants$manifest2$, _Constants$manifest2$2, _Constants$manifest3, _options$baseUrl, _options$url;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var devicePushToken = options.devicePushToken || (yield getDevicePushTokenAsync());\n    var deviceId = options.deviceId || (yield getDeviceIdAsync());\n    var experienceId = options.experienceId || ((_Constants$expoConfig = Constants.expoConfig) == null ? void 0 : _Constants$expoConfig.originalFullName) || ((_Constants$manifest = Constants.manifest) == null ? void 0 : _Constants$manifest.id);\n    var projectId = options.projectId || ((_Constants$manifest2 = Constants.manifest2) == null ? void 0 : (_Constants$manifest2$ = _Constants$manifest2.extra) == null ? void 0 : (_Constants$manifest2$2 = _Constants$manifest2$.eas) == null ? void 0 : _Constants$manifest2$2.projectId) || ((_Constants$manifest3 = Constants.manifest) == null ? void 0 : _Constants$manifest3.projectId);\n\n    if (!experienceId && !projectId) {\n      throw new CodedError('ERR_NOTIFICATIONS_NO_EXPERIENCE_ID', \"No experienceId or projectId found. If one or the other can't be inferred from the manifest (eg. in bare workflow), you have to pass one in yourself.\");\n    }\n\n    var applicationId = options.applicationId || Application.applicationId;\n\n    if (!applicationId) {\n      throw new CodedError('ERR_NOTIFICATIONS_NO_APPLICATION_ID', \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\");\n    }\n\n    var type = options.type || getTypeOfToken(devicePushToken);\n    var development = options.development || (yield shouldUseDevelopmentNotificationService());\n    var baseUrl = (_options$baseUrl = options.baseUrl) != null ? _options$baseUrl : productionBaseUrl;\n    var url = (_options$url = options.url) != null ? _options$url : baseUrl + \"push/getExpoPushToken\";\n\n    var body = _objectSpread({\n      type: type,\n      deviceId: deviceId.toLowerCase(),\n      development: development,\n      appId: applicationId,\n      deviceToken: getDeviceToken(devicePushToken)\n    }, projectId ? {\n      projectId: projectId\n    } : {\n      experienceId: experienceId\n    });\n\n    var response = yield fetch(url, {\n      method: 'POST',\n      headers: {\n        'content-type': 'application/json'\n      },\n      body: JSON.stringify(body)\n    }).catch(function (error) {\n      throw new CodedError('ERR_NOTIFICATIONS_NETWORK_ERROR', \"Error encountered while fetching Expo token: \" + error + \".\");\n    });\n\n    if (!response.ok) {\n      var statusInfo = response.statusText || response.status;\n      var _body = undefined;\n\n      try {\n        _body = yield response.text();\n      } catch (_unused) {}\n\n      throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Error encountered while fetching Expo token, expected an OK response, received: \" + statusInfo + \" (body: \\\"\" + _body + \"\\\").\");\n    }\n\n    var expoPushToken = getExpoPushToken(yield parseResponse(response));\n\n    try {\n      if (options.url || options.baseUrl) {\n        console.debug(\"[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.\");\n      } else {\n        yield setAutoServerRegistrationEnabledAsync(true);\n      }\n    } catch (e) {\n      console.warn('[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service', e);\n    }\n\n    return {\n      type: 'expo',\n      data: expoPushToken\n    };\n  });\n  return _getExpoPushTokenAsync.apply(this, arguments);\n}\n\nfunction parseResponse(_x) {\n  return _parseResponse.apply(this, arguments);\n}\n\nfunction _parseResponse() {\n  _parseResponse = _asyncToGenerator(function* (response) {\n    try {\n      return yield response.json();\n    } catch (_unused2) {\n      try {\n        throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Expected a JSON response from server when fetching Expo token, received body: \" + JSON.stringify(yield response.text()) + \".\");\n      } catch (_unused3) {\n        throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Expected a JSON response from server when fetching Expo token, received response: \" + JSON.stringify(response) + \".\");\n      }\n    }\n  });\n  return _parseResponse.apply(this, arguments);\n}\n\nfunction getExpoPushToken(data) {\n  if (!data || !(typeof data === 'object') || !data.data || !(typeof data.data === 'object') || !data.data.expoPushToken || !(typeof data.data.expoPushToken === 'string')) {\n    throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR', \"Malformed response from server, expected \\\"{ data: { expoPushToken: string } }\\\", received: \" + JSON.stringify(data, null, 2) + \".\");\n  }\n\n  return data.data.expoPushToken;\n}\n\nfunction getDeviceIdAsync() {\n  return _getDeviceIdAsync.apply(this, arguments);\n}\n\nfunction _getDeviceIdAsync() {\n  _getDeviceIdAsync = _asyncToGenerator(function* () {\n    try {\n      if (!ServerRegistrationModule.getInstallationIdAsync) {\n        throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n      }\n\n      return yield ServerRegistrationModule.getInstallationIdAsync();\n    } catch (e) {\n      throw new CodedError('ERR_NOTIF_DEVICE_ID', \"Could not have fetched installation ID of the application: \" + e + \".\");\n    }\n  });\n  return _getDeviceIdAsync.apply(this, arguments);\n}\n\nfunction getDeviceToken(devicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n\n  return JSON.stringify(devicePushToken.data);\n}\n\nfunction shouldUseDevelopmentNotificationService() {\n  return _shouldUseDevelopmentNotificationService.apply(this, arguments);\n}\n\nfunction _shouldUseDevelopmentNotificationService() {\n  _shouldUseDevelopmentNotificationService = _asyncToGenerator(function* () {\n    if (Platform.OS === 'ios') {\n      try {\n        var notificationServiceEnvironment = yield Application.getIosPushNotificationServiceEnvironmentAsync();\n\n        if (notificationServiceEnvironment === 'development') {\n          return true;\n        }\n      } catch (_unused4) {}\n    }\n\n    return false;\n  });\n  return _shouldUseDevelopmentNotificationService.apply(this, arguments);\n}\n\nfunction getTypeOfToken(devicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n\n    case 'android':\n      return 'fcm';\n\n    default:\n      return devicePushToken.type;\n  }\n}","map":{"version":3,"mappings":"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","names":["Application","Constants","Platform","CodedError","UnavailabilityError","setAutoServerRegistrationEnabledAsync","ServerRegistrationModule","getDevicePushTokenAsync","productionBaseUrl","getExpoPushTokenAsync","options","devicePushToken","deviceId","getDeviceIdAsync","experienceId","expoConfig","originalFullName","manifest","id","projectId","manifest2","extra","eas","applicationId","type","getTypeOfToken","development","shouldUseDevelopmentNotificationService","baseUrl","url","body","toLowerCase","appId","deviceToken","getDeviceToken","response","fetch","method","headers","JSON","stringify","catch","error","ok","statusInfo","statusText","status","undefined","text","expoPushToken","getExpoPushToken","parseResponse","console","debug","e","warn","data","json","getInstallationIdAsync","OS","notificationServiceEnvironment","getIosPushNotificationServiceEnvironmentAsync"],"sourceRoot":"","sources":["../src/getExpoPushTokenAsync.ts"],"sourcesContent":["import * as Application from 'expo-application';\nimport Constants from 'expo-constants';\nimport { Platform, CodedError, UnavailabilityError } from 'expo-modules-core';\n\nimport { setAutoServerRegistrationEnabledAsync } from './DevicePushTokenAutoRegistration.fx';\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { DevicePushToken, ExpoPushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\n\nconst productionBaseUrl = 'https://exp.host/--/api/v2/';\n\ninterface Options {\n  // Endpoint URL override\n  baseUrl?: string;\n\n  // Request URL override\n  url?: string;\n\n  // Request body overrides\n  type?: string;\n  deviceId?: string;\n  development?: boolean;\n  experienceId?: string;\n  projectId?: string;\n  applicationId?: string;\n  devicePushToken?: DevicePushToken;\n}\n\nexport default async function getExpoPushTokenAsync(options: Options = {}): Promise<ExpoPushToken> {\n  const devicePushToken = options.devicePushToken || (await getDevicePushTokenAsync());\n\n  const deviceId = options.deviceId || (await getDeviceIdAsync());\n\n  const experienceId =\n    options.experienceId || Constants.expoConfig?.originalFullName || Constants.manifest?.id;\n\n  const projectId =\n    options.projectId ||\n    Constants.manifest2?.extra?.eas?.projectId ||\n    Constants.manifest?.projectId;\n\n  if (!experienceId && !projectId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_EXPERIENCE_ID',\n      \"No experienceId or projectId found. If one or the other can't be inferred from the manifest (eg. in bare workflow), you have to pass one in yourself.\"\n    );\n  }\n\n  const applicationId = options.applicationId || Application.applicationId;\n  if (!applicationId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_APPLICATION_ID',\n      \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\"\n    );\n  }\n  const type = options.type || getTypeOfToken(devicePushToken);\n  const development = options.development || (await shouldUseDevelopmentNotificationService());\n\n  const baseUrl = options.baseUrl ?? productionBaseUrl;\n  const url = options.url ?? `${baseUrl}push/getExpoPushToken`;\n\n  const body = {\n    type,\n    deviceId: deviceId.toLowerCase(),\n    development,\n    appId: applicationId,\n    deviceToken: getDeviceToken(devicePushToken),\n    ...(projectId ? { projectId } : { experienceId }),\n  };\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  }).catch((error) => {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NETWORK_ERROR',\n      `Error encountered while fetching Expo token: ${error}.`\n    );\n  });\n\n  if (!response.ok) {\n    const statusInfo = response.statusText || response.status;\n    let body: string | undefined = undefined;\n    try {\n      body = await response.text();\n    } catch {\n      // do nothing\n    }\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Error encountered while fetching Expo token, expected an OK response, received: ${statusInfo} (body: \"${body}\").`\n    );\n  }\n\n  const expoPushToken = getExpoPushToken(await parseResponse(response));\n\n  try {\n    if (options.url || options.baseUrl) {\n      console.debug(\n        `[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.`\n      );\n    } else {\n      await setAutoServerRegistrationEnabledAsync(true);\n    }\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service',\n      e\n    );\n  }\n\n  return {\n    type: 'expo',\n    data: expoPushToken,\n  };\n}\n\nasync function parseResponse(response: Response) {\n  try {\n    return await response.json();\n  } catch {\n    try {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received body: ${JSON.stringify(\n          await response.text()\n        )}.`\n      );\n    } catch {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received response: ${JSON.stringify(\n          response\n        )}.`\n      );\n    }\n  }\n}\n\nfunction getExpoPushToken(data: any) {\n  if (\n    !data ||\n    !(typeof data === 'object') ||\n    !data.data ||\n    !(typeof data.data === 'object') ||\n    !data.data.expoPushToken ||\n    !(typeof data.data.expoPushToken === 'string')\n  ) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Malformed response from server, expected \"{ data: { expoPushToken: string } }\", received: ${JSON.stringify(\n        data,\n        null,\n        2\n      )}.`\n    );\n  }\n\n  return data.data.expoPushToken as string;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIF_DEVICE_ID',\n      `Could not have fetched installation ID of the application: ${e}.`\n    );\n  }\n}\n\nfunction getDeviceToken(devicePushToken: DevicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n\n  return JSON.stringify(devicePushToken.data);\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment =\n        await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}