{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useEffect, useLayoutEffect, useState } from 'react';\nimport { addNotificationResponseReceivedListener } from \"./NotificationsEmitter\";\nimport NotificationsEmitterModule from \"./NotificationsEmitterModule\";\nexport default function useLastNotificationResponse() {\n  var _useState = useState(undefined),\n      _useState2 = _slicedToArray(_useState, 2),\n      lastNotificationResponse = _useState2[0],\n      setLastNotificationResponse = _useState2[1];\n\n  useLayoutEffect(function () {\n    var subscription = addNotificationResponseReceivedListener(function (response) {\n      setLastNotificationResponse(response);\n    });\n    return function () {\n      subscription.remove();\n    };\n  }, []);\n  useEffect(function () {\n    NotificationsEmitterModule.getLastNotificationResponseAsync == null ? void 0 : NotificationsEmitterModule.getLastNotificationResponseAsync().then(function (response) {\n      setLastNotificationResponse(function (currentResponse) {\n        return currentResponse != null ? currentResponse : response;\n      });\n    });\n  }, []);\n  return lastNotificationResponse;\n}","map":{"version":3,"mappings":";AAAA,SAASA,SAAT,EAAoBC,eAApB,EAAqCC,QAArC,QAAqD,OAArD;AAGA,SAASC,uCAAT;AACA,OAAOC,0BAAP;AASA,eAAc,SAAUC,2BAAV,GAAqC;EACjD,gBAAgEH,QAAQ,CAEtEI,SAFsE,CAAxE;EAAA;EAAA,IAAOC,wBAAP;EAAA,IAAiCC,2BAAjC;;EAKAP,eAAe,CAAC,YAAK;IACnB,IAAMQ,YAAY,GAAGN,uCAAuC,CAAC,UAACO,QAAD,EAAa;MACxEF,2BAA2B,CAACE,QAAD,CAA3B;IACD,CAF2D,CAA5D;IAGA,OAAO,YAAK;MACVD,YAAY,CAACE,MAAb;IACD,CAFD;EAGD,CAPc,EAOZ,EAPY,CAAf;EAYAX,SAAS,CAAC,YAAK;IACbI,0BAA0B,CAACQ,gCAA3B,8CAA0B,CAACA,gCAA3B,GAAgEC,IAAhE,CAAqE,UAACH,QAAD,EAAa;MAIhFF,2BAA2B,CAAC,UAACM,eAAD;QAAA,OAAqBA,eAArB,WAAqBA,eAArB,GAAwCJ,QAAxC;MAAA,CAAD,CAA3B;IACD,CALD;EAMD,CAPQ,EAON,EAPM,CAAT;EASA,OAAOH,wBAAP;AACD","names":["useEffect","useLayoutEffect","useState","addNotificationResponseReceivedListener","NotificationsEmitterModule","useLastNotificationResponse","undefined","lastNotificationResponse","setLastNotificationResponse","subscription","response","remove","getLastNotificationResponseAsync","then","currentResponse"],"sourceRoot":"","sources":["../src/useLastNotificationResponse.ts"],"sourcesContent":["import { useEffect, useLayoutEffect, useState } from 'react';\n\nimport { NotificationResponse } from './Notifications.types';\nimport { addNotificationResponseReceivedListener } from './NotificationsEmitter';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\n\n/**\n * Return value of this hook may be one of three types:\n * - `undefined` until we know what to return\n * - `null` until the app receives any notification response\n * - an object of `NotificationResponse` type - the response\n *   that has been received by the app most recently.\n */\nexport default function useLastNotificationResponse() {\n  const [lastNotificationResponse, setLastNotificationResponse] = useState<\n    NotificationResponse | null | undefined\n  >(undefined);\n\n  // useLayoutEffect ensures the listener is registered as soon as possible\n  useLayoutEffect(() => {\n    const subscription = addNotificationResponseReceivedListener((response) => {\n      setLastNotificationResponse(response);\n    });\n    return () => {\n      subscription.remove();\n    };\n  }, []);\n\n  // On each mount of this hook we fetch last notification response\n  // from the native module which is an \"always active listener\"\n  // and always returns the most recent response.\n  useEffect(() => {\n    NotificationsEmitterModule.getLastNotificationResponseAsync?.().then((response) => {\n      // We only update the state with the resolved value if it's empty,\n      // because if it's not empty it must have been populated by the `useLayoutEffect`\n      // listener which returns \"live\" values.\n      setLastNotificationResponse((currentResponse) => currentResponse ?? response);\n    });\n  }, []);\n\n  return lastNotificationResponse;\n}\n"]},"metadata":{},"sourceType":"module"}